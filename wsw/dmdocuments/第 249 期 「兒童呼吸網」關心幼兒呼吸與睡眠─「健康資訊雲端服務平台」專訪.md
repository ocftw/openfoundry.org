___
 
□■□ 自由軟體鑄造場電子報第 249 期 | 2014/09/16 □■□
___
 
◎ 本期主題︰「兒童呼吸網」關心幼兒呼吸與睡眠─「健康資訊雲端服務平台」專訪
 
◎ 訂閱網址︰[http://www.openfoundry.org/tw/news/](http://www.openfoundry.org/tw/news/)
 
◎ 下次發報時間︰2014/09/30
 
#本期內容#
___


##[源碼專案] 「兒童呼吸網」關心幼兒呼吸與睡眠─「健康資訊雲端服務平台」專訪##


四貓／文


前陣子我們在「睡不好嗎？專訪輔仁大學「基於 HTML5 的跨行動平台響應式睡眠節律服務」文中報導過[「好眠居」](http://hss.weco.net/welcome)這樣專門記錄呼吸與睡眠品質相關性的健康性的網站。今天要為大家介紹的是另一個與呼吸有密切關聯的健康平台[「兒童呼吸網」](www.childbreathnet.com)，就請大家看看透過雲端和網路，醫療照護還有哪些不同的面向囉！


這個專案是馬偕醫學院的王凱微老師和榮總兒童醫學部的宋文舉主任共同主持，而計畫執行人員皆是專業的醫療人員。這個專案原先是一個整合型的專案，目標是針對呼吸道異常病童、移民婦女及安胎婦女等三個族群提供完善的醫療諮詢服務平台，目前「兒童呼吸網」已率先發展成一個獨立的專案，以患有呼吸道異常病童為主要的照護對象，提供病童及家庭照顧者健康服務。  


###平台源起###
   
「兒童呼吸網」是一個以兒童為主要服務目標的呼吸健康資訊平台，除了兒童呼吸道的疾病資訊外，它還有提供兒童的成長發展的資訊，以及醫療設備方面的衛生教育。「兒童呼吸網」也漸漸將目標擴展到其他疾病的族群，例如有一些罕見疾病或是末期病患，也會在呼吸上遇到一些困難，未來他們也希望能夠提供小兒以外的雲端呼吸照護。  
 
王凱微老師談到他們建置這樣的平台的初衷：「現在很多人對醫療的概念是就醫，拿藥之後就回家吃，遇到問題或是病沒好，才再去掛號看診。至於在家中要如何照護病患，大部份醫生沒有特別去宣導，病人家屬多半也不知道去詢問。其實「衛生教育」應是被包含在醫療之中，而且是很重要的一塊，不同疾病發生在不同階段、不同年齡層的病患，帶給家屬的影響是不一樣的。我們希望把這些主題都涵括進來。因為我是兒科老師，專長在教學和研究上，所以我就跟宋主任說，我們各司其職，當宋主任和幸慧姊站在第一線拯救病童的時候，我就負責把平台建好，讓病患家屬有一個地方可以獲得後續的醫療照護資訊。」  
 
###專業支持###


「兒童呼吸網」主要的目標有三大項：一、整合資源及跨領域醫療團隊照護弱勢病童；二、科技化長期照護與多元資訊提供；三、照顧者互惠與適齡客製化教育課程含兒童發展需求計畫。「兒童呼吸網」和其他提供醫療資訊的平台不同的地方在於，他們擁有雙軌制的醫療支持系統：由宋主任帶領醫療團隊提供的正式支持系統，可以促進跨領域醫療團隊與一般照顧者之良性醫病關係，提供線上諮詢、線上預約，和醫師當面諮詢。未來將可望引進視訊諮詢，開啟即時、無障礙之溝通；而非正式的支持系統則是由病友家屬留言互惠，不但可以強化家屬和病友之間的溝通管道，家屬亦可互相給予照護的經驗分享與鼓勵。在諮詢之外，「兒童呼吸網」亦準備了照護案例的影音專區，教導呼吸相關的醫療器具如何操作。即使病患家屬就醫回家忘記如何操作，也可以透過影片的教學再次複習。  


另外除了呼吸之外，平台亦提供嬰幼兒發展相關資訊，共分七大主題，內容包括新生兒照護、幼兒照護、病童照護、寶寶呼吸照顧、早產兒寶寶照護、以及餵養相關問題和預防接種注意事項。下一個階段他們將發展「幼兒發展調查服務平台」，希望建立嬰幼兒相關的資料庫，找出高風險兒童及家庭，以期可以主動提供照護服務。  




**專案網址：**
[健康資訊雲端服務平台](http://www.openfoundry.org/of/projects/2360)   
 
**參考資料：**
[兒童呼吸網](http://www.childbreathnet.com/)
___


##[技術專欄] 運用 Go 語言做 EMR 串流##


謝良奇／翻譯


**本文翻譯自 NY Times，原作者為 JP Robinson：[http://open.blogs.nytimes.com/2014/07/10/emr-streaming-in-go/?_php=true&_type=blogs&_php=true&_type=blogs&_r=1](http://open.blogs.nytimes.com/2014/07/10/emr-streaming-in-go/?_php=true&_type=blogs&_php=true&_type=blogs&_r=1)**


我們的平台團隊使用 Amazon 的 Elastic MapReduce (EMR) 服務，協助我們從日誌檔收集有用的數據。我們有一些程序會抓取日誌檔，接著壓縮並推送到 Amazon S3 上儲存。感謝 EMR，這套模式聚集出回溯數年之久的龐大資訊，等待我們進行資料重整 (data crunching)。一開始我們用 Python 做了不少苦功，不過我們漸漸地轉而依賴 Go。


###開始


當我們一開始使用 EMR，我的團隊用 Python 來寫 mapper 跟 reducer 腳本。之所以選擇 Python，是因為只要最簡單的設定與程式碼，就可以寫出一支能夠從標準輸入讀取 JSON 或 CSV 記錄，並向標準輸出寫出類似結構化資料的 Python 腳本。還有，既然我們已經決定使用 boto Python 程式庫來啟動 EMR 工作流，並管理其輸出，在整個專案中使用同一種語言是較為合理的。


Python 對於簡單的處理做得很好。有一段時間的性能表現相當不錯，既然該腳本十分簡單，我們甚至不需要用到第三方模組。最後，我們遇到的情況需要引入一個內部模組，來重用部分商業邏輯，或是藉由第三方模組來挖掘資料的意義，因此在這個 EMR 工作流增加了新一層的複雜度：bootstrap 動作。


一旦準備完成之後，Bootstrap 動作會在叢集的每一個節點上執行，對於簡單的第三方程式庫，bootstrap 動作可以執行類似 sudo apt-get install python-nltk 的命令。要載入紐約時報內部的程式庫，我們必須把它放在 S3 上，然後寫一支安裝腳本當作 bootstrap 動作。兩種情況都很繁瑣且耗時，我們希望有更優雅的解決方案。既然我們越來越常用 Go 來寫程式庫和服務，我們就想它是不是適用於這個情況。


###改用 Go


我的團隊花了一年時間，用 Go 建構後端服務與 web APIs。正如 Dave Cheney 最近在 Gocon 發表的演說所指出，由於 Go 提供的並行性、易於部署、優秀效能，它通常是一個絕佳的選擇。此外，它的語法清晰，有動態語言的感覺，但又仍屬靜態型別。


當我們在線上有了若干 Go 的服務，我們注意到，在串流 mapper 之中重用這些服務中的部分邏輯，看來是可行的。結果用 Go 來寫 mapper (還有 reducer) 和 Python 比起來，並不會花太多力氣。為了示範，我會並列出用 Python 和 Go 所寫的簡單 mapper/reducer 當作例子。


###Python Mapper


    #!/usr/bin/python
    
    import sys
    import simplejson as json
    
    def main():
    
            # loop through each line of stdin
            for line in sys.stdin:
            try:
    
                    # parse the incoming json
                    j = json.loads(line.strip())
    
                    # initialize output structure
                    output = dict()
    
                    # grab an identifier
                    output["key"] = j["data"]["key"]
    
                    # and any other useful information from input json
                    output["secondary-key"] = j["data"]["another-key"]
                    output["first-metric"] = j["data"]["metric"]
                    output["second-metric"] = j["data"]["metric-2"]
    
            except Exception as e:
                    sys.stderr.write("unable to read log: %s" % e)
                    continue
    
            try:
    
                    # generate json output
                    output_json = json.dumps(output)
    
                    # write the key and json to stdout    
                    print "%s\t%s" % (output["key"], output_json)
    
            except Exception as e:
                    sys.stderr.write("unable to write mapper output: %s" % e)
                    continue
    
    
    if __name__ == "__main__":
            main()


###Go mapper


    package main
    
    import (
             "bufio"
             "encoding/json"
             "fmt"
             "log"
             "os"
    )
    
    func main() {
             var line []byte
             var input logRecord
             var output mapperOutput
             var outputJSON []byte
             var err error
    
             // loop through each line of stdin
             ls := bufio.NewScanner(os.Stdin)
             for ls.Scan() {
              line = ls.Bytes()
    
              // parse the incoming json
              if err = json.Unmarshal(line, &input); err != nil {
                       log.Print("unable to read log: ", err)
                       continue
              }
    
              // initialize output structure
              output = mapperOutput{
                       // grab an identifier
                       input.Data.Key,
                       // and any other useful information from input json
                       input.Data.AnotherKey,
                       input.Data.Metric,
                       input.Data.AnotherMetric,
              }
    
              // generate json output
              if outputJSON, err = json.Marshal(output); err != nil {
                       log.Print("unable to write mapper output: ", err)
                       continue
              }
    
              // write the key and json to stdout
              fmt.Fprintf(os.Stdout, "%s\t%s\n", output.Key, outputJSON)
             }
    
             if ls.Err() != nil {
              log.Print("error reading from stdin: ", ls.Err())
              os.Exit(1)
             }
    }
    
    type logRecord struct {
             Data struct {
              Key               string `json:"key"`
              AnotherKey        string `json:"another-key"`
              Metric            int64  `json:"metric"`
              AnotherMetric int64  `json:"metric-2"`
             } `json:"data"`
    }
    
    type mapperOutput struct {
             Key              string `json:"key"`
             SecondaryKey string `json:"secondary-key"`
             FirstMetric  int64  `json:"first-metric"`
             SecondMetric int64  `json:"second-metric"`
    }


###Python reducer


    #!/usr/bin/python
    
    import sys
    import simplejson as json
    
    def main():
    
            ongoing_count = {"key":""}
    
            # loop through each line for stdin
            for line in sys.stdin:
            try:
    
                    # split line to separate key and value
                    key_val = line.split("\t", 1)
                    key = key_val[0]
    
                    # parse the incoming json
                    data = json.loads(key_val[1])
    
                    # check if incoming key equals ongoing key
                    if key == ongoing_count["key"]:
                    # inrement ongoing metrics
                    ongoing_count["first-metric"] += data["first-metric"]
                    ongoing_count["second-metric"] += data["second-metric"]
    
                    else:
                    # if a new key, emit ongoing counts
                    writeOutput(ongoing_count)
    
                    # set ongoing count with current data
                    ongoing_count = data
    
            except Exception as e:
                    sys.stderr.write("unable to parse reducer input: %s" % e)
                    continue
    
            # emit the final counts
            writeOutput(ongoing_count)
    
    
    def writeOutput(ongoing_count):
            if ongoing_count["key"] != str():
            try:
    
                    # generate json output
                    output_json = json.dumps(ongoing_count)
    
            except Exception as e:
                    sys.stderr.write("unable to create reducer json: %s" % e)
                    continue
    
            # write the key and json to stdout
            print "%s\t%s" % (key, output_json)
    
    
    if __name__ == "__main__":
            main()


###Go reducer


    package main
    
    import (
            "bufio"
            "bytes"
            "encoding/json"
            "fmt"
            "log"
            "os"
    )
    
    var tab = []byte("\t")
    
    func main() {
            var rawInput []string
            var input mapperOutput
            var ongoingCount mapperOutput
            var err error
    
            //  loop through each line for stdin
            ls := bufio.NewScanner(os.Stdin)
            for ls.Scan() {
    
            // split line to separate key and value
            rawInput = bytes.SplitN(ls.Bytes(), tab, 2)
    
            // parse the incoming json
            if err = json.Unmarshal(rawInput[1], &input); err != nil {
                    log.Print("unable to parse reducer input: ", err)
                    continue
            }
    
            // check if incoming key equals ongoing key
            if ongoingCount.Key == input.Key {
                    // inrement ongoing metrics
                    ongoingCount.FirstMetric += input.FirstMetric
                    ongoingCount.SecondMetric += input.SecondMetric
    
            } else {
                    // if a new key, emit ongoing counts
                    writeOutput(ongoingCount)
                    // set ongoing count with current data
                    ongoingCount = input
    
            }
    
            }
    
            if ls.Err() != nil {
            log.Print("error reading from stdin: ", ls.Err())
            os.Exit(1)
            }
    
            // emit the final counts
            writeOutput(ongoingCount)
    
    }
    
    func writeOutput(o mapperOutput) {
            if len(o.Key) == 0 {
            return
            }
            // generate json output
            data, err := json.Marshal(o)
            if err != nil {
            log.Print("unable to marshal reducer output: ", err)
            return
            }
            // write the key and json to stdout
            fmt.Fprintf(os.Stdout, "%s\t%s\n", o.Key, data)
    }
    
    type mapperOutput struct {
            Key              string `json:"key"`
            SecondaryKey string `json:"secondary-key"`
            FirstMetric  int64  `json:"first-metric"`
            SecondMetric int64  `json:"second-metric"`
    }


Go 的實作在程式碼數量上有略微增加，不過，對照 Go 提供的簡易部署和效能提升，還是值得的。由於程式被編譯成單一的二進位檔，我們可以包進我們所需要的所有第三方程式庫，只要將我們的二進位檔放上 S3 就完成了部署工作，也不需要 bootstrap 動作。


我們在速度上有了很棒的提升。我在同一份資料上跑 Go 實作和舊的 Python mapper/reducer，歷經幾次執行之後，我發現平均約提升了 25% 的速度。兩者的這些 mapper/reducers 在 CSV、JSON、regex 上，都使用標準程式庫 (除了 Python 的 simplejson 是個例外)。


當我們持續建構與改進我們的平台技術，我們對 Go 越來越有信心且熟悉。從後台程序到簡單的 MapReduce 腳本，Go 都是我們團隊在伺服器端的優先選擇。它讓我們打造高性能且可靠又易於維護的服務，Go 社群的熱情，加上高品質釋出版本的速度，讓我們樂於渴望看到這套語言的未來。
___
##[自由專欄] 加速非科技公司開放源碼的六個問題##


謝良奇／翻譯


**本文翻譯自 opensource.com，原作者為 Brook Manville：[http://opensource.com/business/14/9/open-new-agenda-business-leaders](http://opensource.com/business/14/9/open-new-agenda-business-leaders)**


一股企業採行出自於開放源碼的策略趨勢正在加速中，透過發展某些致力於開放交換與協作、原型製作導向解決方案、最佳想法勝出的目的導向社群，藉此創造新的價值。


當然開放源碼的路線現已確立於技術領域中。然而或許更加有趣，且更加罕見的是，非科技企業在他們的工作中，開始應用更一般化的開源思考。這雖然不是字面上的開放源碼軟體發展，但卻是社群驅動協作的精神。


有些公司的業務並不是產出晶片、設備、程式，但卻看到了連接圍繞共同目標的自願者網路、開放協作、做中學等途徑的策略價值。最熟悉且簡單的例子是，那些透過鼓勵用戶社群藉由社群網路分享應用和產品故事，以打造品牌經驗的公司。在那些號召開放社群開發或改進新產品與服務，藉此追求創新的公司身上，可以看見更多更加針對性的應用。某些時候這些社群存在於企業內部，存在於跨越組織結構邊界，好的想法得以被發現且加以共同培育之處。但是它們日益出現在公司外部 (以及同時存在內部與外部)，連接員工、客戶、其他自願貢獻者，並透過社群共同創造創新且滿足市場的解決方案。


因此 Charles Schwab 成立了 Schwab 交易社群，以增加所以參與者財富為目標，培育超過 1 萬 1 千位證券交易客戶的協作社群。CEMEX 這家全球商業物資公司，發起了一個稱為 SHIFT 的轉型計劃，動員其數千位員工提出想法，並圍繞該公司六大策略舉措進行創新。Bumble Bee Seafoods 成立了稱為國際海洋產品永續發展基金會 (International Sustainability Seafood Foundation) 產業領先合作，由鮪魚加工業者、科學家、保育環保人士組成的跨領域社群，為該物種與產業的存續，發展並執行管理世界各地瀕危鮪魚的標準。


雖然 Linux 與許多科技公司已經充分顯示，自願者和用戶社群能為開發與支援工作增加可觀價值，非科技公司擁抱類似策略的決策需要相當大的跳躍，以及願意涉足陌生疆域的勇敢領導階層。儘管黑客文化傾向讓技術導向用戶彼此合作解決共同問題，也讓領導者為其企業擁抱此種做法，對於那些從事水泥製造、咖啡銷售、股票與債券交易營銷的管理階層，這一切並不會自動發生。事實上，對於今日的許多非科技領導者，擁抱群眾 (或自願者社群、客戶網路等) 仍是一大未知，而且似乎通常充滿了難以控制的成本和風險。


想踏入開源的領導者經常擔心的障礙，起自於一個天然的偏見：對於傳統管理階層，社群媒體社群或開源途徑似乎是某種罕見且奇蹟般出現的東西，領導者在其中無足輕重。事實上，許多案例證明領導者很重要，雖然許多社群一開始是自我組織，領導者還是有扮演培育、調整、長期維持其價值的角色。許多傳統領導者也會對向社群尋求某種策略協助這種看似矛盾的情況，感到天生的不舒服，因為允許人際網路發展創新解決方案的自由、多樣性、彈性，顯然與確保問責與交付成果的傳統管理要求背道而馳。


當然，這裡還有一個歷久不衰的問題，坦誠地說，許多領導者普遍擔心丟失控制權，或不希望和某些無法定位，且確知其忠誠的臨時雜牌軍，分享權力或光榮。求助於社群如何不悖於來自辦公室角落的利益與可預測性法則？


為了加速非科技企業的開源革新，如今需要的是，學習更多有關領導者，如何在一個逐漸透過自願者社群創造新價值的世界中發揮作用，不管是報導、案例、成功側寫。是的，各種傳聞越來越多，但我們缺少的是詳細的理解，與精心編纂有關成功開源領導者如何以新策略思考且行動的實踐做法。


以下是我們開源社群成員可能會開始權衡的若干問題：


- 有哪些人是今日在其業務中運用開放源碼途徑，最典型的商界領袖？是什麼讓他們獲得成功？
- 他們超越了哪些障礙？怎麼做到的？
- 新形態領導者在治理上的關鍵角色是什麼？為社群招募成員？設定願景？持續參與？解決衝突？
- 在策略上成功採用開源途徑的領導者，其關鍵的心態與行為為何？這些心態與行為是如何學得且實踐？
- 最佳的領導者如何面對分享權力的不確定性？承擔與非傳統人才在非傳統方式下合作的風險？將公司的成功、 機密的資產、產品完整性與品牌，交托給不認識的群眾？
- 最佳的領導人如何適應社群產出的不同風格，像是多元化的方式、更偶發的時間表、瓶頸爭論？


這個清單當然可以，而且也希望它會再加以延伸。這篇文章鼓勵進一步的討論和實踐的塑造。請加入我一同探討領導學習議程。
___


##[源碼新聞] 開放的里程碑：英國政府文件採用開放標準！##


Xu Jia Jun／文


![](www.openfoundry.org/images/140916/OSCD_GOV_open_data_standards.png)


英國內閣廳部長 Francis Maude 於 7 月 22 日[宣佈](https://www.gov.uk/government/news/open-document-formats-selected-to-meet-user-needs)，將以[開放標準 (open standards)](https://www.gov.uk/government/publications/open-standards-for-government) 做為分享及瀏覽英國政府文件的格式，預計所有的政府部門都將採用此項標準。


英國政府採用了相容於常用文書軟體的[標準](https://www.gov.uk/government/publications/open-standards-for-government)：以 PDF / A 或 HTML 瀏覽政府文件，以開放文件格式 (ODF) 分享或協作政府文件，由此確保公民及政府人員在瀏覽或共同編寫文件時，能夠使用符合他們需求的應用程式。當部門採用這些開放標準之後，公民，公司和非營利組織不再需要用特定軟體去開啟或編寫政府文件；公務員能以相同的格式分享及編寫文件，降低在不同格式間轉換時的錯誤發生率；在採購層面，政府組織也可以選擇最具價格效益的軟體，而非只能選特定某幾家大公司的產品。


此舉將為各種規模的供應商創造一個公平競爭的的環境，並預計在這屆國會任期內，可為公民、企業和納稅人省下共12億英鎊的支出。這偉大的一步得來不易，英國政府花費龐大的時間和金錢聽取各政府單位和私營部門的意見，並透過一連串的公共諮詢，蒐集到超過 500 個來自[標準社群 (standards community)](http://standards.data.gov.uk/challenge/sharing-or-collaborating-government-documents) 和一般公眾的回應。


值得一提的是，Opensource.com 在對此事件的[報導](http://opensource.com/government/14/7/uk-government-makes-big-step-forward-open-document-standards)中指出，他們看過幾個政府採用開放標準或開源軟體的[案例](http://opensource.com/government/13/1/open-source-policy-implementation)，但好的政策不一定能帶來好的結果；他們並引用了[歐洲開源論壇 (OFE)](http://www.openforumeurope.org/) 的歐盟會員國政府[採購監管報告](http://www.openforumeurope.org/openprocurement/latest-news-on-procurement/public-procurement-of-ict-products-in-europe-still-afflicted-by-references-to-brand-names)，將公部門採用開放標準一事，拉高到市場公平性的層次：OFE 的新聞稿指出，歐洲國家的採購標案要求特定品牌軟體或標準的情況，今年比去年更嚴重，而這是一種歧視性作法，將小公司排除在投標資格之外，公部門的採購應使用開放標準，才能確保技術中立性 (technological neutrality) 及競爭的公平性。


**圖片來源：Opensource.com**
___


##[源碼新聞] 學生利用 Arduino 製作智慧型設備與科學儀器##


謝良奇／翻譯


**本文翻譯自 opensource.com，原作者為 Jon Davis：[http://opensource.com/life/14/9/tools-scientific-discovery-open-hardware](http://opensource.com/life/14/9/tools-scientific-discovery-open-hardware)**


最近美國國家工程學院 (National Academy of Engineering) 公佈了 14 個 21 世紀的巨大工程挑戰。這個清單看起來很不錯，從推展環境永續性、人類健康，到加強人類能力的資訊技術。不過最引起我注意的，是清單的最後一項，建造科學發現的工具。


作為一名公立高中的科學教師，購買我需要的所有科學儀器，或許已超出我能運用的經費之外，如果用少量經費，就能打造這些儀器那不是很棒嗎？而身為一名遺傳學老師，我了解到，像機器人定序儀 (robotic sequencing machines) 已經加速許多物種的基因組研究。定序方法的進展甚至超越了摩爾定律。我們要如何訓練出能夠建造工具，協助科學家了解自然界的下一代的工程師？其中一個答案是，鼓舞年輕人去想像這樣的計劃，並給予他們完成計劃的工具。在這方面的努力中，Arduino 這樣的開源工具相當具有價值。


Arduino 是作為電子設備原型開發的一款開源微控制器，它可以連接到種類廣泛的低價感測器以收集資料。這些資料可以儲存在 SD 卡，傳回個人電腦或上傳到雲端做後續處理。Arduino 可以起動馬達，建造可以移動且感測的科學儀器。正如 Arduino 共同發明人 Massimo Banzi 在他的 TED 演說中所展示，初中與高中生有能力透過 Arduino 建造科學儀器。在他的例子裡，有學生建構了地震感測器、酸度計，以及各式各樣的機器人。


在我們的教室中，學生在黑客機器人手臂，打造新的人機遊戲介面，為車輛加裝感測器，並且開發能眾包全城臭氧水準的穿戴式空氣污染監測器。


現在，我是一名訓練有素的生物學家，而非工程師，於是製作這些設備的原型在技術上是一大挑戰。幸運的是，在專案開發過程中，我不需要步步引導學生，因為開源社群已經提供了讓他們起步的範例、Arduino 程式碼、文件。學生可以取得現有的程式碼，加以修改，利用他們的創意延伸先前的成果。我認為 Arduino 是個理想的教學平台。它可以讓學生學習寫程式，不過他們的程式碼所做的不只是移動螢幕像素。他們的程式碼會為現實世界中能夠移動、感測，協助我們學習更多有關大自然一切的裝置賦予生命。


為了建構我們的專案，我們使用由 Google 北卡羅萊納科學與數學中學 (NCSSM，North Carolina School of Science and Mathematics) 校友慷慨捐贈的 Google ADK，這是 Arduino Mega 與 Due 的修改版本。Google 是長期的開源技術支持者。歷經數周的原型開發，學生們做出了可以動作的裝置！之後學生們在山景城將專案展示給 Google 員工。


最近我們系上老師被要求開設以工程為重點的課程。我的部分是一系列的新農業科技與生物科技課程。在讀到透過機器人、無人駕駛載具、無線傳感器網路、溫室控制等各種方式，自動化正在推動農業改革時，我發現以上每一種技術都可以用 Arduino 進行自動化。此外，Arduino 事實上正用來作為這些新一代裝置的原型開發。


[加州大學戴維斯分校一間實驗室](http://faculty.engineering.ucdavis.edu/upadhyaya/) 的成員，正使用 Arduino 開發科學儀器與無線感測網路，在加州的極端乾旱期間節約用水。他們的同事開發農業機器人，在勞工短缺時協助加州農場工人。[DIYDrones](http://diydrones.com/) 的社群使用開源 [ArduCopter](http://copter.ardupilot.com/) 與 [MissionPlanner](http://planner.ardupilot.com/)，推動了現代四軸飛行器的發展。在農業上使用無人機作為遠端感測，獲得外界很大的期望。


顯然，目前正是訓練農業學生熟悉 Arduino 開發的絕佳時刻，NCSSM 的農業課程和其他學科的課程一樣，都採用創用 CC 授權在線上開放給大眾。請參考。今年我開始把 Arduino 的使用推廣給其他教師與社群成員，我希望今年能招募到另一批學生，著手開始溫室自動化、無線傳感器網路、無人飛行器、機器人方面的農業專案。我們的目標很簡單，以更少投入種植出更多糧食。更少的投入，我指的是，較少的水、肥料、農藥和耕作。這些投入每一項都很昂貴，同時會對環境造成一些負面影響。這就是開放源碼技術帶來的精密農業！


我總是說教學就是開放源碼，我們老師一直在分享課程計劃、投影片、活動指南。資深教師提供歷史教材協助新進教師，而新進教師則以新穎的想法和最新的技術協助資深教師。開源工具非常適合應用在教育上，因為其自由、可供分享、開放探索與改進，更重要的是，有強大的用戶社群支援。


Arduino 用戶社群以這塊小小的開源電路板，加上開源的 IDE，以及創用 CC 授權的程式碼和文件，創造了一套多樣化的原型開發平台，協助實現了巨大工程挑戰的最後一個項目，也就是建造科學發現的工具。如果你是位需要新儀器的科學教師，請考慮自行製作。開源社群會在這裡協助你。
___


##[源碼新聞] 9/22 討論會「GPL侵權實務在歐洲的近況 - DMFLI1」##


葛冬梅╱文


自由軟體鑄造場將於 9/22 下午舉辦一場小型的討論會，討論會中邀請到著名的自由開源軟體侵權查緝專家 Armijn Hemel，分享其近來在歐洲處理侵權糾紛的經驗。Hemel 先生會將焦點放在最近德國所發生的幾件 GPL 侵權糾紛上，這些侵權糾紛皆由同一位 Linux 核心著作權人所發動，由於這位著作權人向侵權公司要求高額的賠償金，因此在檯面下引發了是否濫用 GPL 的爭議。透過 Hemel 先生的介紹，預計將會討論侵權救濟措施的合理邊際何在？以及當公司在遭遇到類似侵權主張時，有哪些應對措施可以採取。歡迎有興趣的朋友報名參加。


活動詳細議程與報名頁面請見：
[http://dmfli.kktix.cc/events/dmfli1](http://dmfli.kktix.cc/events/dmfli1)


以下文章資訊與本此討論主題相關，歡迎瀏覽：


*  [從 BusyBox 案例看美歐爭訟實務的差異與轉變](http://www.openfoundry.org/tw/legal-column-list/1481-busybox)
*  [從 BusyBox 案談起：台灣業者侵權利用自由軟體所面對的法律風險](http://www.openfoundry.org/tw/legal-column-list/2277--busybox-)
*  [Westinghouse 在 BusyBox 案件之侵權賠償解析－企業應規劃衡量利用自由軟體的法律風險](http://www.openfoundry.org/tw/legal-column-list/8144-westinghouse-busybox-)
*  [LGPL-3.0 訴訟案例解析：FreeAdhocUDF 侵權和解案](http://www.openfoundry.org/tw/legal-column-list/8986-introduction-to-lgpl-30-lawsuit-freeadhocudf)
___


##[接案工作] 自由軟體鑄造場-徵軟體工程師 ##


黃儀銘╱文


**主要工作內容：**


- 網站開發、維護
- Web server 管理


**必備條件：**


- 網頁開發經驗（請在履歷中附上作品或開發經驗）
- SQL 指令、MariaDB/MySQL 或其他 RDBMS
- Unix-like 操作經驗（如：FreeBSD, Ubuntu, CentOS 等）
- 積極負責任、注重團隊合作
- 對程式具有熱情、樂於學習新知


**加分條件：**


- 曾參與自由開源軟體專案開發
- Ruby on Rails 開發經驗
- 懂 MVC pattern
- 會使用版本控制系統（VCS），如：Git, SVN 等
- 具備前端開發能力（HTML, CSS, JavaScript 或 jQuery ...）
- 使用或開發過 RESTful API
- 歡迎身心障礙朋友


**其他：**無工作經驗可


**需求人數：**1 人


**薪資：**依中央研究院規定，大學以上 3.3 萬～3.9 萬


**上班時間：**週一至週五早上9:00 ~ 下午18:00，週休二日


**應徵方式：**


- 將您的履歷寄至 ymhuang |AT| citi.sinica.edu.tw
- 履歷中請註明姓名、聯絡方式、可開始工作時間、學歷
- 履歷檔案格式請用 ODP 或 PDF
- 如資格不符，將不另行通知，資格符合者，會在一週內利用email 通知面試
- 若您有作品，歡迎附上，讓我們可以多了解您 :)
___




#關於本報#
 
 
◎ 主編︰洪華超
 
◎ 法律專欄編輯︰葛冬梅
 
◎ 執行編輯︰洪立穎
 
◎ 外稿編譯︰林誠夏、黃郁文、謝良奇
 
本電子報自行採訪、報導、編譯、撰寫文章之智慧財產權屬於中央研究院，採用創用CC「姓名標示－禁止改作－非商業性」授權條款臺灣 3.0 版授權散布，歡迎在不變更內容的前提下，以任何形式重製與散布本報，但必須遵守下列義務︰(1) 不得為商業目的之利用；(2) 必須標明本電子報智慧財產權屬於中央研究院；(3) 完整引用本著作權說明。
 
若欲以創用CC「姓名標示－禁止改作－非商業性」授權條款臺灣 3.0 版以外的方式利用上述文章，請與自由軟體鑄造場編輯群(ossfepaper at openfoundry.org) 聯絡。
 
非自由軟體鑄造場自行撰寫的單篇文章，其智慧財產權利屬於原作者所有，其以非專屬的方式授權予自由軟體鑄造場運用，而與本電子報其他文章併以創用 CC「姓名標示－禁止改作－非商業性」授權條款臺灣 3.0 版的方式進行散布。
 
若欲以創用CC「姓名標示－禁止改作－非商業性」授權條款臺灣 3.0 版以外的方式利用個別作者的文章，請自行與該作者聯繫，或透過自由軟體鑄造場編輯群 (ossfepaper at openfoundry.org) 來轉發聯絡訊息。
 
授權條款全文請見︰
[http://creativecommons.org/licenses/by-sa/3.0/tw/legalcode](http://creativecommons.org/licenses/by-sa/3.0/tw/legalcode)
 
授權條款簡介請見︰
[http://creativecommons.org/licenses/by-sa/3.0/tw/deed.zh_TW](http://creativecommons.org/licenses/by-sa/3.0/tw/deed.zh_TW)
 
若欲訂閱本電子報，請至以下網址︰
[http://www.openfoundry.org/tw/news](http://www.openfoundry.org/tw/news)
 
如欲取消訂閱這份電子報，可透過自由軟體鑄造場新聞首頁左上方之自動退訂機制︰
[http://www.openfoundry.org/tw/news](http://www.openfoundry.org/tw/news)
 
或寄發電子郵件至︰ossfepaper@openfoundry.org，以進行人工退訂。