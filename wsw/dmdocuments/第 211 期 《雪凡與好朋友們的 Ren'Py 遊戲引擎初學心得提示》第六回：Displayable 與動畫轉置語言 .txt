________________________________________________________________

□■□ 自由軟體鑄造場電子報第 211 期 | 2013/1/15 □■□
________________________________________________________________

◎ 本期主題︰《雪凡與好朋友們的 Ren'Py 遊戲引擎初學心得提示》第六回：Displayable 與動畫轉置語言
◎ 訂閱網址︰http://www.openfoundry.org/tw/news/
◎ 下次發報時間︰2013/1/29

□ 本期標題 □__________________________________________________

■ [源碼秘技] 《雪凡與好朋友們的 Ren'Py 遊戲引擎初學心得提示》第六回：Displayable 與動畫轉置語言

■ [源碼秘技] 如何閱讀 Rails 原始碼

■ [源碼專案] 程式碼分析工具 AdLint 公開

■ [源碼新聞] 鼓勵女性參與開源創作的 Ada Initiative

■ [源碼新聞] 煙霧為 Blender 2.65 帶來了火焰

■ [源碼新聞] 令人震驚：Android SDK 二進位檔案仍是私有軟體

■ [源碼新聞] 三個你沒聽過的 Linux 散佈套件

■ [源碼新聞] Wikipedia 漸採 MariaDB 來代換 MySQL

■ [源碼新聞] Linux 基金會提供 Android 開發課程

■ [源碼新聞] LibreOffice 4.0 Beta 已釋出為馬拉松測試準備就緒

■ [源碼新聞] Freescale 等公司加入 Linux 基金會

■ [接案／工作] 自由軟體鑄造場 - 誠徵「工讀生」
_______________________________________________________________


□ 本期內容 □__________________________________________________

■ [源碼秘技] 《雪凡與好朋友們的 Ren'Py 遊戲引擎初學心得提示》第六回：Displayable 與動畫轉置語言

林雪凡／文

嗨！大家好！感謝大家觀賞本回的《雪凡與好朋友們的 Ren'Py 遊戲引擎初學心得提示》。我是雪凡。

今天的主題，是華麗麗的圖片與動畫特效。


(http://www.openfoundry.org/images/130115/renpy6/Head_Text_1_5.jpg)「因為有很多的文字需要應付，所以本回的助手就是我了。我是泰克斯 (text)。」

咦？很多文字嗎？本回的重點應該是圖片才對吧？你在說什麼啊？

(http://www.openfoundry.org/images/130115/renpy6/Head_Text_1_1.jpg)「你才是在說什麼......用來操作圖片的 Displayable 實體，以及 ATL 動畫轉置語言，不管那一項都是被程式碼給團團包圍的東西。Ren'Py 官網的說明頁面可是寫了長長一大落......不要裝傻！」

原、原來如此......這麼說來也是。想要讓華麗的圖片與動畫乖乖工作，仔細一想還真是少不了文字的幫助啊......

(http://www.openfoundry.org/images/130115/renpy6/Head_Text_1_13.jpg)「......你應該是在裝傻吧？」

當、當然！那還用說嗎？我可是有預習的。總、總、總而言之！華麗麗的圖片與動畫，是給玩家玩遊戲時享受的，至於我們這些遊戲製作者，只要以感恩的心，努力發揮遊戲製作者的天賦......

(http://www.openfoundry.org/images/130115/renpy6/Head_Text_1_12.jpg)「......提問：遊戲製作者的天賦是什麼？」

那、那個、就是那個嘛......那個，你知道的，就是......

(http://www.openfoundry.org/images/130115/renpy6/Head_Text_1_14.jpg)「是什麼呢？」

大概是......M......？......之類的？

(http://www.openfoundry.org/images/130115/renpy6/Head_Text_1_10.jpg)「......」

那種眼神是怎樣，不要用那種眼神看我！

(http://www.openfoundry.org/images/130115/renpy6/Head_Text_1_12.jpg)「抱歉，各位觀眾朋友，看來今天好像只有我了。」

喂！喂喂！等等......我只是早上還沒完全睡醒而已。再給我一次機會......呃，遊戲製作者所需要的東西，果然是「毅力、根性以及熱情」對吧。

(http://www.openfoundry.org/images/130115/renpy6/Head_Text_1_15.jpg)「還有技術啊！」

呃，那是當然。不過技術什麼的，就由本節目來為您介紹吧。

讓我們一起進入本回正題！

(http://www.openfoundry.org/images/130115/renpy6/Head_Text_1_13.jpg)「正是如此！」



螢幕上的圖片定位法

剛開始時大家精神正好，先補完一些簡單的圖片定位與螢幕座標小常識。


螢幕上的座標

如果各位年齡夠大，學過初中數學，想來還記得平面直角座標這回事。

(http://www.openfoundry.org/images/130115/renpy6/Renpy_06_01_Cartesian-coordinate-system.jpg)
▲ 圖1：數學課中常見的標?平面座標系統。x 軸從左到右遞增，y 軸從下到上遞增；原點位置在中間的 (0,0) 處。看狀況不同，有時也會略去負數部份，將原點直接畫在左下角。

在電腦螢幕上座標系統也是雷同，唯一的差異在於，螢幕的 y 軸是由上到下遞增的；因此，座標系的原點 (0,0) 也被擺到了左上角。正如下圖這般......

(http://www.openfoundry.org/images/130115/renpy6/Renpy_06_02_screen_coordinate.jpg)
▲ 圖2：螢幕座標系統示意圖。以 800x600 螢幕做為範例。

y 軸反過來很奇怪嗎？

然而這種平面座標形式，倒不是 Ren'Py 自行規定的，而是全世界的電腦程式都是這樣。不管 Linux 或 Windows，Direct X 還是 Gimp......全部都一樣，幾乎沒有例外。也算是一種業界標準吧。

除了螢幕以外，圖片座標也是用同樣方式定義的：

(http://www.openfoundry.org/images/130115/renpy6/Renpy_06_03_image_coordinate.jpg)
▲ 圖3：圖片座標系統示意圖。以 400x350 螢幕做為範例。

結合「螢幕」與「圖片」這兩套座標系統，我們可以動手把圖片放到螢幕上面。比方說，將圖片放到螢幕的 (200,50) 位置上......

(http://www.openfoundry.org/images/130115/renpy6/Renpy_06_04_place_image.jpg)
▲ 圖4：將圖片放在螢幕的 (200,50) 位置之示意圖。圖片的原點，會自動錨定在指定的座標點上。

發明這一切的傢伙看著一切所造的都甚好，圖片可以順利定位、貼到螢幕上，這就?備去幹些別的去了。

不過偏偏有人這時問了：

「我想要將圖片置中，或是貼齊右下角，怎麼辦？」

(http://www.openfoundry.org/images/130115/renpy6/Renpy_06_05_place_image_center_wrong.jpg)
▲ 圖5：想讓圖片置中時，試著直接指定螢幕正中央的座標 (400,300) ......但這顯然不對！光原點置中有什麼用啊！

學院派的同學可能馬上想要試著推導公式，這種做法當然沒錯。

以置中來說，很快就能看出，要指定的座標應為：
(http://www.openfoundry.org/images/130115/renpy6/5.5.jpg)

......不過，果然還是算了吧！難道您真打算每次想要對齊哪裡時，都用手來算、來推導公式嗎？

雖然在某些低階遊戲引擎中您還真非手算不可，但在 Ren'Py 中倒不必如此。

為了處理這個小麻煩，我們得引進「錨點 (anchor)」的概念。


【低階與高階的遊戲引擎】這裡的高階與低階，並不是好或差的意思。而是指「與人類間的距離」。

－－這麼說吧，越高階的引擎，他的運作方式就會越與人類的想法相近（會去配合人類）；反之，低階的遊戲引擎則不那麼去重視人類的想法，而是去配合、適應電腦內部的實際運作狀況。

這表示引擎越高階，就越容易被我們操縱；反之越低階，功能往往越強，彈性也會高，速度也會快，但也需要不少基礎知識，與好幾年的研究才能精通。

在各種遊戲引擎中，Ren'Py 算是比較高階的引擎。不過也請注意，低階與高階都是相對性的，只有在互相比較時才有意義。


錨點 = 黏合點

所謂的錨點，是指「位於圖片座標系統中的一個座標點」，當圖片要定位時，這個座標點－－僅僅一個小點－－就能代表整張圖片所在的位置

......這麼說好像挺複雜的，但其實我們早已用過以上的概念。記得嗎？前面提過，當我們給圖片指定一個座標時，圖片的原點就會與我們給定的座標點重合－－這表示那時我們正把「原點」當成「圖片的錨點」在用！

(http://www.openfoundry.org/images/130115/renpy6/Renpy_06_06_place_image_anchor.jpg)
▲ 圖6：預設狀態下，錨點的位置在圖片左上角的原點處。另外還請注意此處只是示意圖，錨點實際上是看不到的。

但說到底，「以原點為錨點」僅僅只是 Ren'Py 的預設值，我們也可以把錨點設在圖片的其他位置上。

(http://www.openfoundry.org/images/130115/renpy6/Renpy_06_07_place_image_anchor_center.jpg)
▲ 圖7：將錨點設於圖片正中央－－(200,175)－－的示意圖。請留意一件事：錨點是設在圖片上的，而不是設在螢幕上，這非常重要。

在 Ren'Py 中，設定錨點有很多方法，比方說我們稍後會提到的 ATL 動畫轉置語言，或是在宣告圖片時指定等等......嗯！具體要怎麼做，等會兒再說。

(http://www.openfoundry.org/images/130115/renpy6/Renpy_06_08_place_image_center_right.jpg)
▲ 圖8：和圖5 指定了相同的顯示座標 (400,300)，但實際顯示結果，卻因錨點 (anchor) 位置不同而大不相同。請留意圖上的錨點位置，會和指定的座標位置相重合（圖5 也是如此）。

很顯然，有了錨點作為圖片座標系統的擴充後，我們就能輕易實作各種圖片的對齊效果了！......比方說，想把圖片對齊到右下角，只要將錨點設在圖片的右下角 (400, 350)，再將圖片移到螢幕的右下角位置 (800, 600) 上，就能完成對齊......整套操作一目了然，不用再導公式了！

錨點與螢幕座標畢竟是比較抽象的話題，如果您無論如何都看不明白咱在這長篇大論地說些什麼，也可以去官方的 Tutorial Game 中找愛琳(Elieen)教授上上課。請在官方 Tutorial Game 的課程選單中，選擇 "Screen Positions" 這一項就可欣賞。

－－噢，小心，愛琳教授是會考試的。

Displayable

在 Ren'Py 中，有不少和圖片看似雷同、可被顯示在螢幕上......但要說那是圖片，又不太一樣的東西存在。這些可被顯示的東西，含圖片在內，一律被稱為 "Displayable"。而能接受 Displayable 的變數，則稱之為 Displayable 變數。

不用擔心又冒出了新名詞。絕大多數您之前打過交道的，看似是要填入圖片的變數，幾乎都是 Displayable 變數。

舉例來說，options.rpy 檔案中的「主選單圖片設定用參數」：menu_root （第四回時介紹過，還記得嗎？），就是個 Displayable 變數；而用來設定對話框背景的 style.window.background－－這個變數中可以簡單地放入圖片，但我們後來也有將其指定為一個「可自行拉伸的 Frame」－－沒錯，那也是個 Displayable 變數！


Displayable 變數的賦值

像 menuroot 這樣的 Displayable 變數，有以下幾種值可被賦予／指派給他們：

＊包含「.」的字串，如："school.png"
    這個字串會被理解為圖片的檔名。Displayable 變數會因此被設為一個 Image。
＊由「#」開頭的字串，如："#AA0000"
    理解為網頁色碼。Displayable 會被設為一個 Solid。（Solid 是 Displayable 中的一種，咱們稍後再聊）
＊構造為 (red, green ,blue ,alpha) 的管串 (tuple)，如：(211, 31, 161, 255)
    這同樣代表填色用的 Solid，不過是換了種表示方式。
    管串中每個數字都須在 0 ~ 255 之間，其中 alpha 代表透明度，255 表示完全不透明。
＊其他字串，如："emiya smile"
    理解為用 image 語句定義的圖片名稱。
＊由 Displayable 函式產生的 Displayable 物件，如第四回時介紹的 Frame()

以下來段示範：

image window bg = "window_bg.png" # 先定義一張圖片，等會兒示範時會用到......

style.window.background = "window_bg.png"  # 指定為 window_bg.png 這張圖片
style.window.background = "#FF000088"      # 指定為 紅色 + 50% 半透明
style.window.background = (255, 0, 0, 128) # 同上，指定為 紅色 + 50% 半透明
style.window.background = "window bg"      # 指定為 image 那行定義的圖片
style.window.background = Frame(...)       # 指定為某個 Frame (... 的部份表示，具體定義細節被我省略了)


Displayable 的類型

光前面提過的就有 Solid、Image、Frame ......可以想見 Displayable 並不只一種......

呃......老實說吧，Displayable 不但不止一種，還不止一類。

(http://www.openfoundry.org/images/130115/renpy6/Head_Text_1_13.jpg)「以下略加整理後介紹給各位。請看。」

圖片型 Displayable

圖片型 Displayable 有三大特徵：

＊會在螢幕上佔據一個矩形區域。
    其中有些類型的 Displayable，大小會由 Ren'Py 引擎自動設定好－－如 Solid，會自動填滿可顯示範圍。至於另一些，可由遊戲作者手動設定。
＊不會對玩家的輸入（如滑鼠移動等）起反應與互動。
＊圖片型 Displayable 支援所有 Position Style 屬性 (http://www.renpy.org/doc/html/style.html#position-style-properties) －－顧名思義是用來設定圖片位置用的－－屬性不少，不忙去背，需要設定時再查表就好了。

具體說來，圖片型 Displayable 有以下幾種：

＊Image()
    輸入檔名載入圖檔，圖檔可以是 jpg 或 png－－這其實就是各位平時在用的普通圖片。
＊Frame()
    製作對話框之類的外框圖片專用。
    輸入 xborder、yborder，會讓 x 軸邊框部份 xborder 像素範圍內，以及 y 軸邊緣部份 yborder 像素範圍內的圖片，保持正常不改變，但內部的圖則會隨 Frame 的?高，被動態地拉伸壓扁（如果 tile 為 True 則用「拼貼」取代拉伸）
    第四回時有詳細介紹使用方法，忘記的同學請務必回去看看。
＊LiveCrop()
    切下某張圖片的其中一部份作為本 Displayable 的顯示內容。
＊LiveTile()
    將某張小圖片作為拼磚的原料，填滿 LiveTile 內所有可顯示的空間。
＊Null()
    空圖片。空空的啥也沒有，不過可指定大小，也可以作為排版時留空使用。
＊Solid()
    指定色碼給出純色。
＊Text()
    將文字視視為圖片來顯示
    －－第三章的範例檔案中，最開始處標題畫面的旋轉文字，就是靠這東西做的。

簡單示範一下使用方式：

# 以下兩行意義完全一樣
style.window.background = 'win_background.png'
style.window.background = Image('win_background.png')

# 以下兩行意義完全一樣
style.window.background = Solid('#FF0000')
style.window.background = "#FF0000"

......總而言之，用 Displayable 的類型如 Image，加上括號，並填入適當參數就能將 Displayable 製造出來。

上述圖片型 Displayable 使用說明與可用參數列表，詳見官網此頁 (http://www.renpy.org/doc/html/displayables.html#image-like-displayables) ，不過 Text 的使用說明則要參看這裡 (http://www.renpy.org/doc/html/text.html#text-displayable) 。


動態 Displayable

比圖片型 Displayable 更加抽象的，是動態 Displayable。

動態 Displayable 本身「不會被顯示」，取而代之，它會佔據一般 Displayable 的位置，作為其他 Displayable 的「容器」，並依照各種條件，切換顯示內部的 Displayable......

嗄啊！這到底是在說什麼啊！

(http://www.openfoundry.org/images/130115/renpy6/Head_Text_1_4.jpg)「別吐自己的嘈啊。」

嘛啊......為了普適的定義，話居然說得連自己都聽不懂了。

......也罷，反正數量也不多，直接說明了吧。

共分為三種：

＊ConditionSwitch
    依據 if 條件式來改變顯示內容
＊DynamicDisplayable
　給定一個 Python 函式，每隔一段時間就執行一次，並用該函式回傳的 Displayable 來顯示。
　Python 函式的回傳值，還能控制「隔多久」要重新計算 Displayable 的內容。
＊ShowingSwitch
　依據當前畫面上某些 displayable 是否有顯示，來變更本 Displayable 的顯示內容。

如果需要的話，官方說明可以在這裡 (http://www.renpy.org/doc/html/displayables.html#dynamic-displayables) 找到。

ConditionSwitch

ConditionSwitch 可以用 if 條件式來決定要顯示什麼圖片。

見下：

image 圖片名 = ConditionSwitch(
    "能產生真假值的 Python 語句?", 語句?為 True 時要顯示的 Displayable,
    "能產生真假值的 Python 語句?", 前方語句均為 False，且語句?為 True 時要顯示的 Displayable,
    "能產生真假值的 Python 語句?", 前方語句均為 False，且語句?為 True 時要顯示的 Displayable,
    # 以此類推，只要確保參數兩兩成對就好，可以有更多……
    "True", "前面全部不符合時，要顯示的 Displayable" # 什麼都不符合時，需要有一個預設值。
    )


實際示範使用方式：

image superhero = ConditionSwitch(
    "mask == 'blue'", "hero_bluemask.png",
    "mask == 'red'", "hero_redmask.png",
    "True", "hero_default.png"
    )

label start:
    $ mask = 'red'

    show superhero with dissolve    # 此處顯示 hero_redmask.png
    "就算角不存在，我的速度也能突破天際。不要小看我啊啊啊啊！！！"

    $ mask = 'blue'                 # superhero 一圖隨變數改變，自動改成顯示 hero_bluemask.png
    "那傢伙失控了，大家快阻止他！"

    $ mask = 'yellow'               # 自動改成顯示 hero_default.png
    "阻、阻止不了啊！他可是紅色……呃啊！"

DynamicDisplayable

DynamicDisplayable 可以用自定義的函式，控制要顯示什麼圖片。

自定義的函式格式，如以下所規定：

# 自定義的函式－－這是 python 碼，當然要定義在 python block 中
# return 值需為一個具有兩個元素的 tuple，不明白 tuple 的同學請見第四章的介紹。

def my_func(顯示的秒數, 相同 tag 持續顯示的秒數):
    return (要顯示的 Displayable, 下次呼叫本函式應該在幾秒之後)


【自定義函式】 您之前介紹過，函式 (function) 就是將一堆的功能與工作，打包集中起來的一個方法。

不管是 Ren'Py 還是 Python，本身都有提供大量的函式。但這些現成的函式，方便歸方便，郤不可能為我們天馬行空的妄想……特殊要求量身訂製，因此也有需要自己定義／設計函式的時候。

此處不細講函式定義的細節，因為這玩意兒的小邊角實在太多啦，我們只要照虎畫喵地喵喵看就好。反正都是貓科......

(http://www.openfoundry.org/images/130115/renpy6/Head_Text_1_6.jpg) 泰克斯：「不，就算你這麼堅持也......」

沒問題沒問題！不管是用來做什麼的函式，其格式總是如下：

def 函式名(參數?名稱，參數?名稱, 參數?名稱, ...): # 各參數之間需用 "," 隔開，至於參數數量則可多可少，一個都沒有也可以
　　# 在函式內部，對參數做各種處理與計算 ...

　　# 完成計算後將解答返還
　　return 解答 具體舉一個例子：

# 定義一個計算兩數平均值的函式
def average(A, B):
　　 answer = (A + B)/2
　　 return answer

# 使用
average_result = average(1024, 35212)


以下是一個實際可用的 DynamicDisplayable 範例，定義了一個可顯示在螢幕上的簡單計時器：

# 定義函式：
# 函式名稱怎樣取都可以，這邊簡單取為 timer_func
init python:
    def timer_func(show_time, same_tag_show_time):

        # 下方三行表示會使用 "Timer: show_time/same_tag_show_time" 的格式來顯示
        timer_text = 'Timer: {st:.1f}/{stst:.1f}'.format(
            st = show_time,
            stst = same_tag_show_time)

        return (Text(timer_text), 0.1) # 每隔 0.1 秒更新一次

# 用定義的函式搭配 DynamicDisplayable 來定義圖片
init:
    image timer = DynamicDisplayable(timer_func) # 將 timer_func 指定給 DynamicDisplayable


# DynamicDisplayable 定義完成，這就試用看看吧
label start:

    show timer at topright # 讓計時器顯示在右上角，兩數均從 0.0 起算
    "計時開始"

    show timer at topleft # 讓計時器變到左上角去，show_timer 重設為 0.0 但 same_tag_show_time 依然繼續計時
    "變更位置"

    hide timer
    "重設"

    show timer at topcenter # 讓計時器顯示在正中央，兩數均從 0.0 起算
    "計時再度開始！"


(http://www.openfoundry.org/images/130115/renpy6/Renpy_06_09_timer_right.jpeg)
▲ 圖9：剛顯示時，兩者同時計數。

(http://www.openfoundry.org/images/130115/renpy6/Renpy_06_10_timer_left.jpeg)
▲ 圖10：沒有 hide 直接重新 show 之後，只有 show_time 被重設。

這些特性要怎麼運用就看您了。

ShowingSwitch

ShowingSwitch 可依據螢幕上當前正在顯示的圖片，來決定 ShowingSwitch 本身要顯示的是什麼。

運用此一特性……舉例來說，我們可以僅僅只指定立繪的表情，就讓側欄圖片 (side image) 的表情也跟著立繪的表情自動改變！這個範例官網本身就有，見此 (http://www.renpy.org/doc/html/displayables.html#ShowingSwitch) ，這邊不重複。


【側欄圖片 (side image)】 
側欄圖片是對話框旁邊，用來顯示人物表情的小圖片。如下所示： 
(http://www.openfoundry.org/images/130115/renpy6/Renpy_06_11_side_image.jpeg)
▲ 圖11：左下角那個就是 side image......哼哼，效果挺不錯的吧。

什麼，您問側欄圖片如何啟動？如何使用？
啊啊......這其實應該是要在第四章聊到的內容，不過當時沒空去講......這邊趕快補完一下！

用範例說明重點，見下：
# ====== 以下內容通常放在 options.rpy 中 =======

init -1 python hide:
　　 # 將對話框內的文字左邊界往右移，以免圖片蓋到文字。
　　 # 這裡調的是 padding，但當然也可以去調整 margin，兩者效果各有不同。
　　 style.window.left_padding = 316

# ====== script.rpy ======

init -1 python hide:
　　
　　 # 將對話框內的文字左邊界往右移，以免圖片蓋到文字。
　　 # 這裡調的是 padding，但當然也可以去調整 margin，兩者效果各有不同。
　　 style.window.left_padding = 316

# ====== script.rpy ======

init:
# 定義圖片
　　 image library = "bg/library.png"

　　 image no talk = "char/no_talk.png"
　　 image no soliloquize = "char/no_soliloquize.png"

　　 # side image 宣告時，名字用 side 開頭
　　 image side no talk = "char/side_no_talk.png" # side image 圖片的尺寸是隨意的，預設對齊到左下角
　　 image side no soliloquize = "char/side_no_soliloquize.png"

　　 # 定義說話角色
　　 # Charactor() 的 image 參數，請對照 side image 宣告時用的第二個字節
　　 define no = Character("小諾", image = "no")

# 遊戲從此開始......
label start:
　　scene library 　 　　　# 顯示背景，
　　show no talk at right 　# 如果沒有這行，變更 side image 並不會顯示立繪
　　　　　　　　　　　　# 反之若立繪存在，立繪也會隨 side image 變動而自動變更。

　　no talk "所以我就說不要隨便邀請那傢伙到家裡來嘛！姊......姊姊！聽我說話啦！妳從已前就是這樣......我、我真的要生氣囉！" # 隨本句對話顯示，side image 會被設為 side no talk

　　no soliloquize "鳴！就算你這麼說也……" # 隨本句對話顯示，side image 會被設為 side no soliloquize（角色的立繪有顯示的話，會被自動修改為 no soliloquize；反之若畫面上沒有顯示立繪的話，則也不會多事地去顯示它。）

return

滿足了嗎？更詳細的說明請見官網這一頁 (http://www.renpy.org/doc/html/side_image.html) 。 


Layout Displayable

這一類型的 Displayable，可用來將多個 Displayable 組合起來，方便畫面佈局使用。在設計 screen 畫面時常常用到。（不過我們還沒聊過 screen......這以後再說！）

共有三種：HBox（水平箱）、VBox（垂直箱）、Fixed（固定佈局）。

HBox 與 VBox

HBox 和 VBox 可以將多個 Displayable，以水平或垂直的方向連續拼裝起來（變得像是一排按鈕列那樣）。用法也很單純。

image pictures v = VBox("image_1.png", "image_2.png", "image_3.png", ...)
image pictures h = HBox("image_1.png", "image_2.png", "image_3.png", ...)


......雖然上面非常老實地進行了示範，但我們通常不會這樣直接用它，而是會透過 screen language 在 screen block 中使用。故這邊不細講，到時候再說。

Fixed

相比 VBox 與 HBox，Fixed 就有彈性多了。

(http://www.openfoundry.org/images/130115/renpy6/Head_Text_1_1.jpg) 「雖然這和 "Fixed" 的字面意思對照不太起來。」

那個啊......不要在意細節啦！

image icon corner = Fixed(
        Image("icon.png", xalign=0.0, yalign=0.0),  # 將一個小 icon 放在 fixed 的座標系統的左上角。
        Image("icon.png", xalign=1.0, yalign=0.0)   # 將一個小 icon 放在 fixed 的座標系統的右上角。
    )


【Fixed 的定位與大小】 既然提到「對齊」，那麼 Fixed 的座標系統，其範圍又是如何呢？

－－或是這樣問吧：Fixed 的左上角與右下角，到底是在（螢幕的）哪裡？

答案是：Fixed 預設會覆蓋全螢幕！

Fixed 的左上角就是螢幕的左上角，Fixed 的右下角就是螢幕的右下角（預設）。Fixed 會佔據全螢 幕，哪怕內容物只是個小小圖示也是如此。

......佔滿全螢幕這點，這有時會給我們帶來一些意料外的麻煩。比方說：想用 Fixed + Image + Solid 替某張去背後的道具圖片，上一些簡單的背景色時，Solid 的顏色不光填滿道具圖背後的空間，還 把全螢幕都一起填滿！或是想用 show fixed_images_group at right 語句移動「含一群小圖片的整個 Fixed」時，因為 Fixed 佔滿全螢幕而完全移不動。達不到想要的效果。

反正總之，也會有要調整 Fixed 覆蓋範圍的時候。

如果您想調整 Fixed 的範圍，請用 area、maximum 等 Position Style (http://www.renpy.org/doc/html/style.html#position-style-properties) 屬性來設定。如下：

image item cup red_background = Fixed(
　　　　 Solid("#335555"), 　 # 底色
　　　　 Image("cup.png"), 　 # 道具杯子的圖片。後出現的會壓在先出現的上面，故會蓋到底色之上。
　　　 maximum = (256, 256) # 設定 item cip red_background 這個 fixed 最大限度（在此等於指定尺寸）。注意內容物要是大小超過範圍，會有部分被裁掉。
　 )

在上例中，如果你不知道杯子圖的大小或懶得計算，也可以用 fit_first 參數 (http://www.renpy.org/doc/html/style.html#style-property-fit_first) 替代 maximum。見下：

image item cup red_background = Fixed(
　　　Image("cup.png"), # 道具杯子的圖片。搭配 fit_first 可設定 Fixed 的大小範圍與本圖片的大小相同。
　　　Solid("#335555"), # 底色，會蓋過上面的杯子圖。
　　　Image("cup.png"), # 道具杯子的圖片。實際顯示用。
　　　fit_first = True # 將當前這個 Fixed 的大小，設為內部第一個 Displayable 的大小。
　)

 Fixed 在拼裝多個 Displayable 這方面，可說是彈性十足，但也因此使用時需要大大發揮您的想像力。更多示範，還請自行參閱官網 (http://www.renpy.org/doc/html/displayables.html#layout-boxes) 的說明吧。


ATL 動畫轉置語言

ATL：Animation and Transformation Language 動畫與變形處理語言，這是用來處理上述眾多 Displayable 的好東西！

即使是最基本的 ATL 運用，也可以輕易地對 Displayable 進行各種縮放、平移、旋轉等 transform（變形）操作，還可在變形的過程中呈現動畫。除此之外，也有些像是調整 alpha channel 之類的追加操作。而在適用範圍方面，能運用 ATL 的也不限於圖片 (Image)－－所有的 Displayable 都能用 ATL 加以處理，包括某些看似不是圖片的 Displayable，比方說 Fixed 這種。

【Transformation（變形／轉置）】在電腦圖學中，Transform / Transformation 是一個中文意思與英文意思有著些許落差的專有名詞，不太好翻......它指的是數學上的 linear transformation (http://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2)。

呃，數學細節不去管啦。總而言之 Transform 這個字，乍看之下像是改變形狀，但事實上，是三種基本操作－－平移 (Translation)、旋轉 (rotation)、縮放 (scaling)－－這三個動作（以及三者的衍生動作，如翻轉、對齊等）的通稱。

也就是說，像把圖片往螢幕右側移 20px 這種，看起來「形狀」根本就沒有任何改變的操作，也算是 Transform（變形）的一種。閱讀本文時還請稍微注意。

如果您對這方面的數學有興趣，請查找關鍵字「變換矩陣 (http://zh.wikipedia.org/wiki/%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5) 」。


ATL 是好用，但也不是什麼地方都能放入 ATL 的程式碼。

它只能被放在以下三個地方：

＊Transform block 內
    Transform block......傷腦筋，這要怎麼解釋好呢？
    －－這麼說吧。還記得第三回中提過的「show 圖名 at 位置」的秀圖語法嗎？
    其實 at 後面放的，並不光只是區區的「位置」而已。更精確地說，at 後面那些 topright、center、right 等物，其實一個個都是透過 transform 語句定義的 "transform" （變形描述）。
    將常用的 transform 定義出來，可以讓圖片操作和圖片本身份開。不過這方面我們日後有機會再講，此處不提。
＊image block 內
    image 定義語句本身也可以寫成區塊的型式，內部用來盛放 ATL 語句。等會兒您會看到很多這種範例。
＊scene & show block 內
    show 與 scene 語句同樣可寫成 block 的型式，並在內部裝入 ATL 語句。想當然，這種 ATL 僅做為一次性消耗品來使用，show 完就沒了，不能重用。


(http://www.openfoundry.org/images/130115/renpy6/Head_Text_1_13.jpg) 「接下來的示範多以 image block 中的 ATL 為主，其他兩種為輔。原理都是相同的，還請自行類推。」

不管怎麼說，先來個簡單範例，看看 ATL 到底長什麼樣：

# 這是個 image block
image drum beat:
    "drum_1.png" 
    pause 0.5
    "drum_2.png"
    pause 0.5
    repeat


解釋：

# 以下是做為對比的，一個「沒有動畫的鼓」的圖片定義。（不含 ATL）
image drum = "drum_1.png"

# 以下是一個「讓兩張圖片交替切換的打鼓動畫」之圖片定義。
image drum beat:

    "drum_1.png"   # 聲明要顯示的 Displayable 為 drum_1.png
    pause 0.5      # ATL 語句：操作目前顯示中的 Displayable（drum_1.png）暫停 0.5 秒
    "drum_2.png"   # 聲明要顯示的 Displayable 換成 drum_2.png
    pause 0.5      # ATL 語句：操作目前顯示中的 Displayable（drum_2.png）暫停 0.5 秒
    repeat         # ATL 語句：重複當前語句塊（從 "drum_1.png" 那行重新開始）


嗯哼，語句非常簡單直觀不是嗎？下面我們就來深入瞭解一下。



ATL 屬性陳述

ATL 屬性陳述是整個 ATL 系統的基礎。它可設定的項目極度繁多，但非常簡單。

請看以下這些範例。

移動圖片到 (0, 50) 座標處：

image img1 = "image1.png"

label start:

    # 第一種寫法，這邊也示範一下 show block
    show img1:
        pos (0, 50) # ATL 屬性陳述 (pos)：讓圖片的位置，與螢幕的 x 軸 = 0, y 軸 = 50 座標點重合
                    # 補充：請別忘記，圖片的具體位置與它的「anchor（錨點）」有關。（請見本回最前面的理論說明）

    # 第二種寫法：分開指定 x 與 y 的座標數值，效果完全等同於第一種寫法。
    show img1:
        xpos 0      # ATL 屬性陳述 (xpos)：圖片的 x 軸位置，與螢幕的 x 軸 = 0 座標點重合
        ypos 50     # ATL 屬性陳述 (ypos)：圖片的 y 軸位置，與螢幕的 y 軸 = 50 座標點重合 


移動圖片對齊螢幕左下角：

image img2 = "image2.png"

label start:

    # 第一種寫法
    show img2:
        align (0.0, 1.0)    # ATL 屬性陳述 (align)：將圖片座標系統中的 anchor（錨點），與螢幕座標系統中的圖片位置座標，同時移動到 (0.0, 1.0)
                            # 注意這邊的座標值被指定為浮點數（有小數點的數）！這表示此一數字其實代表一個「百分比數」：0.0 = 0%, 1.0 = 100%, 0.4 = 40% ……以此類推！
                            # 反之若為整數，如 (20, 40)，則表示這是一個以像素做為單位的座標。

    # 第二種寫法，效果完全等同於第一種寫法。
    show img2:
        pos (0.0, 1.0)      # ATL 屬性陳述 (pos)：移動圖片到指定位置
        anchor (0.0, 1.0)   # ATL 屬性陳述 (anchor)：移動錨點到指定位置

    # 第三種寫法，效果也相同。
    show img2:
        pos (0.0, 1.0) anchor (0.0, 1.0) # 多行合併，這種寫法也沒問題

    # 其他可能寫法……
    show img2:
        xpos 0.0 ypos 1.0 xanchor 0.0 yanchor 1.0

    # 這樣寫也行
    show img2:
        xalign 0.0 yalign 1.0


旋轉：

# 圖片順時針旋轉 30 度：
image img3:
    "image3.png"
    rotate 30


設定透明度：

image img4:
    "image4.png"
    alpha 0.5    # 透明度 50%


撿取圖片的一小部份：

# 從立繪中撿取出頭部圖片……
image head:
    "character.png"          # 立繪之類的大圖
    crop (50, 40, 128, 128)  # ATL 屬性陳述 (crop)：擷出 (x, y, width, height) 做為顯示內容


－－示範到這種程度應該很夠了。

各位想來也早已發現，ATL 屬性陳述，就僅僅只是用來指定圖片的某些基本屬性而已。

這些屬性陳述可設定的項目非常之多，請去看看官網此頁 (http://www.renpy.org/doc/html/atl.html#list-of-transform-properties) 取得完整列表。這些屬性中，有些只吃一個數字，有些吃二元或四元 tuple 數字，還有些是吃真假值的......大多用常識就能判斷了！

忘記 tuple 是什麼的同學，請回頭參看第四章。

Transform 執行順序

在一張圖片同時被指定了多種 transform 操作的情況下，transform 的套用順序也是很重要的。舉例來說－－各位可簡單想像一下，先縮放再靠右對齊，和先靠右對齊再縮放......後者一定對齊不了！效果當然是不一樣的。

Ren'Py 已經規定了，各 transform （與類似 transform 的操作，如裁切）會依照以下順序套用：

＊裁切圖片：
    crop、corner1、corner2
＊設定基本圖片大小：
    size
＊縮放：
    zoom、xzoom、yzoom
＊旋轉相關操作：
    rotate
＊定位：
    pos、xpos、ypos、align、xalign、yalign、xcenter、ycenter

如果轉置後的效果和您想像中不太一樣（依個人經驗，這特別容易在旋轉操作中發生），還請確認一下 transform 的執行順序。


【舊版 Ren'Py 的 transform 套用順序】此處列出的順序，是 6.14 版（也就是本節目製作時的最新版本，於 2012 年 8 月推出）時的順序。至於 6.13 及更早之前的版本，其 transform 套用順序並不一樣。一言以蔽之，舊版是將 rotate 操作放在縮放操作之前。

官方對變動的說明，請參閱此處 (http://www.renpy.org/doc/html/changelog.html#transform-changes) 。

OK！屬性陳述的基礎打好後，讓我們進一步深入 ATL 吧。



動畫與插值陳述

前面我們進行屬性陳述時，雖然能自由地讓圖片移動變形，但是，那一切都是在瞬間發生的！

換言之，沒有動畫！

對於一款遊戲來說，這實在是無法令人感到滿意。

為了讓操作能支援動畫效果，我們需要引入插值陳述。

【插值 (Interpolation)】 哦不......我不想在這裡討論這種無法用「一言以蔽之」、「不要在意細節」來帶過的數學問題。不 過因為這件事事關動畫，咱們還是試試看好了。

請看以下這張圖片：
(http://www.openfoundry.org/images/130115/renpy6/Renpy_06_12_interpolation_linear.jpg)
▲ 圖12：本圖為線性 (linear) 插值的示意圖
時間進行到 t% 時，變化率為多少？－－這個問題就是「插值」所要解決的核心問題。

我們將其放到遊戲中看看。
在您指定一個動畫時，一定會指定動畫終止時的狀態（比方說向右平移 200 像素，又或是旋轉 45 度），同時也會指定執行時間（比方說要花 2 秒）。

那麼一來，只要您指定了一個插值方式，比方說上述的 linear 線性插值法，電腦就能自動計算出所 有可能的中間畫面。

舉例來說，在需要向右平移 300 像素，動畫時限 2 秒的情況下，使用上圖所示的線性插值......

　　＊ 當動畫播到第 0.4 秒 (20%) 時，圖片應該位在向右平移 20%......也就是向右 60 像素的位置上。
　　＊ 動畫播到第 1 秒 (50%) 時，圖片應該位在向右平移 50%......也就是向右 150 像素位置上。
　　＊ 當動畫播到第 1.8 秒 (90%) 時，圖片應該位在向右平移 90%......也就是向右 270 像素位置上。
　　＊ 動畫播到第 2.0 秒 (100%) 時時間用完，圖片會位在向右平移 100%......也就是向右 300 像素的最終位置上。整　　　 個動畫事件到此完成，移動終了。

「呃，等等......聽起來好像是沒錯啦，但你鬼扯那麼多幹嘛？－－時間 75% 時，變化自然會是 75%－－那不是理所當然的事情嗎？」

不，並非如此。

時間 75% 時，變化 75% 這種「等比例變化」情況，僅止於使用線性公式 (http://zh.wikipedia.org/wiki/%E7%B7%9A%E6%80%A7) 的 linear 線性插值法時。如果您使用了其他的插 值曲線，那就需要另當別論。

請見下面這張圖：
(http://www.openfoundry.org/images/130115/Renpy%206/Renpy_06_13_movement-profile-standard.jpg)
▲ 圖13：預設的幾種 Transition（轉埸）插值示意圖。雖然此處我們是在講 ATL，不過插值曲線都 是相同的。其中紅色的 "move" 轉埸曲線，就是前述的 linear 曲線（直線）。

看上圖。綠色的 ease 曲線在時間 20% 時，變化率才 10%；而時間 80% 時，變化率居然就變成了 90%......這表示中間 60% 的時間中，產生了 80% 的變化率。所以採用 ease 插值的動畫才會有「慢 －快－慢」的效果。

其他插值曲線也各有各的效果，請務必嚐試著琢磨看看。

如果您有興趣的話，還可以自行定義自己想要的特殊插值曲線－－比方說：動畫播放過程中，先 讓變化率突破 100%（以移動來說就是移動過頭）！ 然後再反彈回 100% 的插值法。方法可參看這一頁 (http://www.renpy.org/wiki/renpy/doc/cookbook/Additional_basic_move_profiles) 。
(http://www.openfoundry.org/images/130115/Renpy%206/Renpy_06_14_interpolation_pause.jpg)
▲ 圖14：（順便補充）如果您有興趣的話，pause 的插值曲線是長 成這樣。

可選的插值方式有以下 5 種：
＊ pause
先暫停，然後在時間到期時，瞬間完成變動（因此只有延時功能，看不到動畫）。
＊ linear
以恆定速度進行變化。
＊ ease
以「慢－快－慢」的速度進行變化。
＊ easein
以先快後慢的速度進行變化。
＊ easeout
以先慢後快的速度進行變化。

以上幾種插值法的官網說明，詳見這一頁 (http://www.renpy.org/doc/html/atl.html#warpers) 。 用法舉例如下：

init:
　　image img = "image1.png"

label start:
　　show img:
　　　# 先設定初始位置：左側螢幕的外面（看不見的地方），圖片底部與螢幕底部切齊
　　　anchor (1.0, 1.0)
　　　pos (0,0, 1.0)

　　　# 用 ease 插值法將動畫移入，對齊螢幕左下角。（費時一秒）
　　　ease 1.0 align (0.0, 1.0)

另一個例子：持續旋轉動畫

init:
　　image gear:
　　"gear.png"
　　rotate 0　　 　# 設角度為 0
　　linear 10.0 rotate 360 　 # 花十秒旋轉 360 度
　　repeat　　　 # 執行完之後再重覆（repeat 等等會講到）

label start:
　　show gear # 顯示
　　"顯示一個旋轉中的齒輪"



簡單型與複雜型的 ATL 語句

ATL 語句有兩種類型：簡單型與複雜型。

簡單型只要單行就能完結，甚至可以允許一行裡面連續出現好幾個。比方說之前提過的插值陳述，就是簡單型語句：

show johan:
    ease 1.0 xalign 0.5 yalign 0.5      # 在 1 秒內用 ease 插值法將圖片移到指定位置（螢幕正中央）

複雜型是必需用 block 寫成的語句。比方說下面的 contains 語句：

# 在 pic 這個 Displayable 中同時顯示兩個 Displayable
image pic:
    contains:     # ATL 語句
        "#f00"
    contains:     # ATL 語句
        "image.jpg"

以下從複雜型開始介紹起。


ATL 中的複雜型語句

雖然名為複雜型，但只是名字如此而已，個人感覺比簡單型還容易理解－－只需要記得這些複雜型語句都是區塊，那就差不多會用了。

主要有以下幾種：

＊block
    沒有特殊功能的區段，不過搭配 repeat 使用，可使 repeat 語句造成的重複效果，範圍被限制在 block 之內。
＊contains
    定義一個完整的（次級）ATL 區段。
    如果您在一個普通 ATL 區段中，放入多個單獨的 contains，就能一次顯示多張獨立的 Displayable，並附帶他們各自的動畫特效。
    順便說明，contains 是用 Fixed 實作的，很多特徵都相同。感到困惑時可對照著 Fixed 參考看看。
＊choice
    choice 在 ATL 中，一次總是出現多個。效果是在多個 choice 中隨機多選一，挑一個來執行。
＊parallel
    如果 ATL 中一次出現多個 parallel 區塊，將會「同時」執行這些 parallel 區塊中的內容。（而非預設中的「依序」執行）
＊on
    用「on show:」或「on hide:」等方式開始。當相應事件發生時，就會去執行區段中的內容。
    比方說可以在 show 與 hide 等不同時機，使用不同的轉場動畫。
　on 預設可用的事件列表在此 (http://www.renpy.org/doc/html/atl.html#external-events) 。


用法很簡單，幾乎可說是千篇一律。以 choice 為例就像是這樣......

# 隨機選擇一張圖片
image random_image:
    choice:           # 看！本章提及的 ATL 語句就用在這裡
        "image1.png"
    choice:
        "image2.png"
    choice:
        "image3.png"


在這其中，contains 比較特別，除了可以當作區段來使用以外，還可以直接單行使用。不過這時的 contains 和作為區段時的 contains，語義上有著小而重要的不同......因為在下覺得沒有非用不可的理由，加上容易造成誤解，這就不去囉嗦了。有興趣的同學可以參見官網的這一頁 (http://www.renpy.org/doc/html/atl.html#contains-statement) 。

插值外常用的簡單型語句

time、pass、repeat 都是簡單型 ATL 語句，都是要和 ATL 中的 block 合併使用才有意義。其意義也很單純，合併介紹如下。

time 是一個「基於時間的攔阻器」－－一定要等到時間到了，才會給後續語句放行。和 pause 用法略有不同。

# 浮現 img 後，過 3 秒又消失掉
show img:
    alpha 0.0             # 初始狀況：完全透明
    linear 1.0 alpha 1.0  # 花一秒時間顯示
    time 3.0              # time 的時間是從進入 block 起算，第 3 秒後才能通過運行

    # pause 2.0           # 可替換 time 那一行，效果非常相似（因為 pause 的 2.0 秒 + linear alpha 的 1.0 秒 = 3.0 秒）

    linear 1.0 alpha 0.0   # 花一秒時間消失


pass 是一個佔位子用的符號，本身沒有任何功能，不過當您就是需要一個留空的區塊時，它就能派上用場。

# 用 show 顯示時，隨機變更一個放大倍率
show img:
    choice:
        zoom 0.5
    choice:
        zoom 0.75
    choice:
        zoom 1.0
    choice:
        zoom 1.5
    choice: # 不改變圖片本身預設的放大倍率
        pass


repeat 我們在之前的例子中已經見過了幾次，他是用來重複執行同一個區塊用的。

show img:
    alpha 0.0    # 初始化：完全透明
    block:
        linear 1.0 alpha 1.0
        linear 1.0 alpha 0.0
        repeat   # 重複執行當前區段，以本例來說就是 block 內的內容


簡單型語句並不只有這些，此處只是以我個人的偏見，向各位介紹最常用又好用的幾項。如果需要完整的 ATL 語句列表，還請參見官方手冊 (http://www.renpy.org/doc/html/atl.html) 。


總結

ATL 與 Displayable 的簡述，到此算是告了一個段落。

一如預期，本回程式碼到處肆虐......各位覺得如何呢？

頭會不會痛那種小事姑且不論，ATL 與 Displayable 的知識很實用倒是真的。想要創造出美麗的畫面，以上的東西可是基本功，相信各位今天也該多少有了些體會才是。

(http://www.openfoundry.org/images/130115/renpy6/Head_Text_1_1.jpg)「沒錯。不過話說回來，我從剛剛就有點介意......除了一開始之外，你這傢伙今天倒是沒怎麼胡鬧呢。」

呃？......什、什麼嘛！......那不是理所當然的嗎？不要說得我好像老是在打混一樣啊！

(http://www.openfoundry.org/images/130115/renpy6/Head_Text_1_4.jpg)「那就暫時當作是這樣吧。」

什麼暫時！本人嚴重覺得自己遭受了不正當的侮辱！我要抗......

(http://www.openfoundry.org/images/130115/renpy6/Head_Text_1_3.jpg)「那麼，就向各位預告一下下一回的內容－－」

不要露出那麼燦爛的笑容啊！聽我說......

(http://www.openfoundry.org/images/130115/renpy6/Head_Text_1_3.jpg)「下回，本節目會繼續補完其他和圖片顯示有關的東西－－想知道如何創造隨機飄落的雪花或花瓣？猛烈的暴風雪？甚至是在帶著微光的地下室中，那些流盪閃爍的漫漫塵埃？或是如何在遊戲中，動態改變原始圖片的色調，創造出將普通圖片變成泛黃照片那類效果？對了，如果時間足夠的話，也會和各位聊聊自定義轉場 (Transition) 的方法。」

......啊啊！台詞又被搶走了！ 你這個笨蛋，這下我要怎麼收場啊？

(http://www.openfoundry.org/images/130115/renpy6/Head_Text_1_12.jpg)「煩死人......那種事隨便怎麼樣都好啦......」

(http://www.openfoundry.org/images/130115/renpy6/Head_Text_1_14.jpg)「而且，這麼說起來，不是還有些很重要的話可以說嗎？......像是『敬請期待』之類的。這充份彰顯了你的存在意義呢。」

......我的存在意義和被捏扁的螞蟻一樣嗎？

而且你不覺得，你最近和絲蔻兒那傢伙愈來愈像了嗎？

(http://www.openfoundry.org/images/130115/renpy6/Head_Text_1_9.jpg)「咦？等等......」

總之－－次回的 Ren'Py，請各位務必用力期待！
_______________________________________________________________

■ [源碼秘技] 如何閱讀 Rails 原始碼

XDite ／文

◎本文原載 Blog.XDite.net，原文章連結 (http://blog.xdite.net/posts/2012/11/25/how-to-read-sourcecode/) 。

開始有計畫整理一些在 RubyConf China (http://rubyconfchina.org/) 大家線下問我的問題的答案。

挑選出來暫定的第一篇是大會期間詢問度最高的：「如何閱讀 Rails 原始碼」。

想要「閱讀 Rails 原始碼」的原因很多，不過多半的出發點都是想要能夠設計出更好的 Plugin (Gem)、或者是希望能在程式碼出錯時，能夠更快在 Rails 原始碼快速找到答案。

但擺在眼前的事實是， Rails 的原始碼已經成長大到成幾萬行的怪獸，如何「看懂」或者是有效率的找到答案，已經變成是一個很大的難題。

以下是我根據這幾年的經驗，能夠給各位的建議：


1. 從單純的部分切入，例如 Helper

最令大家頭疼的地方是，這麼多程式碼，要從哪部分開始讀起。

如果你是初心者，想要跳進這個池子裡，想找點簡單的東西讀，我會建議你先從「Helper」的部分開始讀。「Helper」是整個 Rails 程式碼裡面最獨立的部分（不牽扯到 request 呼叫），而且結構相對單純。


2. 從 request 開始，到 rack，到 routing，到 controller，最後再到 model

我真正開始有系統的讀懂 Rails code，是從一門線上 Owning Rails (http://owningrails.com/) 開始的。這門課的宗旨是，就是教你有效掌握搞懂 Rails 的核心與結構。相當有趣的是，他並不是教你讀任何 Rails 代碼，而是實際一步步帶你造出一個「mini Rails」。而造完這個 「mini Rails」之後，學員也能夠開始神奇的開始擁有快速找 code 的能力。

我在去年曾經寫過一篇 Owning Rails masterclass (http://wp.xdite.net/?p=2407)介紹過這個課程。

第一天：造出自己的 mini Rails

帶你如何寫出精簡版 ActiveRecord、寫 rack app、用 rack app 改出精簡版 ActionController、自己 implement 出 before, after, around_ filter、自己 implement 出 view。然後最後再用你自己刻出來的這套 mini Rails 寫 web application。

第二天的課程

Refactor 昨天寫的 mini Rails，教你如何 trace Rails core。利用 Rails internal API 客製化出你想要的特殊 function、library。作業有 custom validator、custom finder、create responder、create form builder、使用 Railtie 客制 Engine、造 plugin。

宥於這是付費課程的關係，我也無法公開提供各位更進一步的教材內容。但是我能夠告訴各位這們課程為什麼會這樣設計，讓你可以也依循著這個軌道去自我進修。
rack

一個 request 進來，首先通過的是層層的 rack middleware。所以必須要先理解什麼是 rack，rack 的運作原理是什麼。可以試著自己先寫一個 rack app 玩看看。

如果想知道 Rails 裡面的 request 流程會經過哪些 middleware，被加過哪些工。可以在 Rails 專案裡面打 rake middleware，再去把 class 一個一個叫出來讀。
routing

request 通過 rack 層進來後，首先面對的是 dispatch 問題，Rails 透過 routes.rb 進行 dispatch。而如何 dispatch 到正確的 controller，中間靠的就是 regexp。
controller

開發者在 controller 會牽涉到兩個常用的相關機制：Filter 與 View Rendering。Filter 時怎麼運作的。method 應該是回傳「值」，怎麼做到自動回傳的是 render 出來的 view。
model

ActiveRecord 的上一層就是一套 ActiveModel API。其實 Rails 不一定要靠 ActiveRecord，也可以透過實作一個 Class 加上部分機制做出自己的 ORM。其中 validation, finder 都是這方面的課題。


3. 搞懂 Rails 的啟動流程

RailsCast China (http://railscast-china.com/) 曾經 release 過一個很好的影片：The Rails Initialization Process By kenshin54 (http://railscasts-china.com/episodes/the-rails-initialization-process-by-kenshin54) 講解了整個 Rails 啟動流程。你也可以讀由 Ruby on Rails 官方釋出的這篇官方教學啟動流程 (http://guides.rubyonrails.org/initialization.html) 去更加了解啟動過程中究竟會經過哪些檔案，如果要寫 plugin 可以 hook 在哪一些部分。


4. 實際簡單寫一個 Rails Plugin

最好的學習方法就是動手實作。在看過以上這一些資料之後，我建議你可以實際透過開發一個 Gem 去更加了解整個 Rails 內部的結構。

目前 Rails Plugin 幾乎都是以 Engine Gem 的形式釋出。所以透過撰寫一個 Gem，可以了解到：

＊如何將自己的 Library 與現有 API 整合。
＊如何將自己的 Library 掛 / 不掛進啟動 process 中。
＊Engine 與 Railtie 的結構。
＊如果有相依檔案，如何撰寫 generator，把檔案放進去 project 裡面。
＊如果有檔案操作和客製選項，如何透過 thor 這個工具去達到檔案修改的目的。

算是一個相當好的鍛鍊。


5. 讀別人（熱門）的 Rails Plugin

有時候，想要實作某一些功能不得其法。最好的方式就是去讀有類似功能的 Gem，去看看其他作者怎麼做的。有時候會翻到他們用了不少你根本不知道的 Rails API。

順著他們用這些 Rails API 的方法，可以更快的在 Rails 原始碼找到你要的答案...


小結

希望以上的方法能夠協助各位更快的上手讀通 Rails 的原始碼。有任何問題歡迎留言在底下討論。
_______________________________________________________________

■ [源碼專案] 程式碼分析工具 AdLint 公開

Kenneth Mak／文

◎本文原載 Linux Pilot，原文章連結 (http://www.linuxpilot.com/software/kiji/2012030501AdLint)。

企業要全面採用開源技術，其中必須經過的難關，便是要說服管理層有關安全性的問題。有人認為全面開放程式碼的產品沒有閉源產品般安全，原因是經過太多開發人員的修正，當中可能影響程式碼的質素甚至會造成漏洞，這次介紹的 AdLint 便是有效的解決方案。

(http://www.openfoundry.org/images/130115/201203050101.jpg)

開源產品因為程式碼對外公開，已經經過無數次的審查，安全性比較高是必然的。問題是採用開源技術的企業，卻不一定有能力親自去對程式碼再檢查一次，這時 AdLint 便能夠幫忙。AdLint 免費的程式碼靜態分析工具，本身亦是開源的程式，它可以對程式碼進行品質測定，目前可分析根據 ANSI C89、ISO C90 及部分 ISO C99 規格編寫的 C 語言程式碼，並輸出警告訊息，其 1.0 正式版本已於 2012 年 2 月 29 日公開。

以往要發現軟體產品的潛在問題，必須由開發者親自檢視程式碼，AdLint 可將此等功能自動化，從不同視點進行調?、總結出所謂的軟體品質測量 (Software Quality Metrics)。軟體品質測量是計算軟體質量的一套量度標準，例如要測量軟體的是否可靠，便可以利用平均故障間隔 (MTBF) 表示軟體的正常運作時間和發生問題時間的比例。開發者可利用 AdLint 在一定時間內建立的數據，從而觀測軟體品質測量數值的變化。

AdLint 由日本 Ogis 總研的開發者開發，並可配合同公司另一套開源程式碼品質評估工具 Adqua 使用，將程式碼品質評估過程可視化。AdLint 擁有與程碼編譯工具式相同的工作界面，可以與 Eclipse 等跨平台工具一起使用，直接跳至程式碼中有問題的部分。AdLint 現時可輸出多達 597 種警告訊息，可測定多達 15 種軟體品質測量，並可在 Windows XP、Windows 7 及各種 Linux 版本上運作，條件是必須安裝 Ruby 1.9.3-p0 或以後的版本、及 GNU Make 3以後的編譯環境。AdLint 採用 GNU GPL version 3 授權，可在 Sourceforge 網站下載。
_______________________________________________________________

■ [源碼新聞] 鼓勵女性參與開源創作的 Ada Initiative

黃郁文／編譯

近幾年崛起的網路應用，不論是 Larry Page 與 Sergey Brin 共同創辦的 Google，或是網路新秀－Facebook、Zynga，Groupon，可說都與自由開源軟體的善加利用息息相關。但在這樣的趨勢之下，開放源碼社群中，女性成員竟然只佔 2%，相較於整個資訊界女性從業人員約佔業界 20%，數據上顯然有著相當大的落差。其實根據調查，有女性位居要位的的公司，通常更能靈活運用資本，長期下來將為公司帶來更多營收。另外，工作小組成員多元化的團隊，其所研發的產品及服務，也較能兼顧不同消費者族群的個別需求。所以眼下縮小自由開源軟體界的性別差距，實在是當務之急。

Ada Initiative 就是著眼此一狀態而成立的專職機構，於 2011 年 2 月成立，是為推動女性加入自由開源軟體業界、Wikipedia，以及其他開放科技領域所成立非營利組織，該組織並以歷史上第一位電腦工程師 Ada Lovelace 之名，當作組織名稱，希望藉由舉辦各種工作坊，以及提供免費教學與諮詢服務，來完備女性開發者跨入自由開源軟體界所需的協助與技術。到目前為止，Ada Initiative 所進行活動，有鼓勵女性參與開放技術的非正式會議 (unconference) 議程 AdaCamps、推行遠離性騷擾政策、舉辦鼓勵進用女性之免費演講或座談、免費參與的技術教學工作坊，以及針對女性在資訊產業就職方面相關的各項市場調查。

接下來，Ada Initiative 還會陸續舉辦各種活動，預期透過這些活動的推展，讓女性參與自由開源軟體界的聲音與需求，能被更多領域的人注意到，並進一步擴大女性跨入開放科技的空間與機會。不獨有偶的是，國內也有在相同理念下，推動女性參與自由開源軟體領域的團體－WoFOSS - 台灣女子自由軟體工作小組 (Women in Free and Open Source Software in Taiwan),這是由一群在國內參與自由開源軟體活動的女性朋友組成的社群，透過定期聚會以及相關活動的舉辦，發出聲音，並以行動塑造，對女性更友善更自在的資訊環境。值得感興趣的各方朋友，可以對此方面的活動多加關注！

相關網址：

1. 為何我們需要更多女性加入開源行列
http://opensource.com/life/12/12/founder-gap-why-we-need-more-women-open-source

2. The Ada Initiative 官方網址
http://adainitiative.org/

3. Ada Initiative 回顧與展望
https://www.linux.com/news/featured-blogs/196-zonker/520792-the-ada-initiative-looking-back-and-looking-forward

4. 「Unconference」係蝦米碗糕？原來是活潑好玩的新型會議
http://www.openfoundry.org/en/foss-forum/8422-introduction-of-unconference

5. WoFOSS好自由 - 台灣女子自由軟體工作小組
http://wofoss.blogspot.tw/
_______________________________________________________________

■ [源碼新聞] 煙霧為 Blender 2.65 帶來了火焰

謝良奇／編譯

最新版的開放源碼 3D 模型與影片制作工具 Blender 現在有了火焰模擬與運動模糊功能。Blender 的前次釋出加入的許多功能，都是在 Blender 基金會最新電影專案 Tears of Steel 期間所開發。隨著該專案的結束，開發者們表示在 Blender 2.65 中，他們主要著重在該應用軟體的穩定性，修改了超過 200 個程式錯誤。

新的火焰模擬是 Blender 現有煙霧產生器的附加功能，將提供火焰、煙霧，或者火焰加上煙霧的效果。3D 視圖預覽中看得到產生的煙霧或火焰。煙霧產生器也獲得改善，允許煙霧可從網格表面發出，而無須粒子系統。開發者還加入了煙霧流動力場，以協助控制發出的煙霧。透過這個功能，用戶可以讓煙霧與火焰對氣流等其他模擬效果作出反應。

網格模型工具的改進與新的修改器 (modifiers) 讓用戶在創建與修改模型時有更多控制能力。開發者現在也可以用 Open Shading Language，為 Blender 的 Cycles 顯示引擎，撰寫客制的渲染器 (shaders)。

Blender 2.65 也增加了運動模糊渲染功能，能用來讓移動中物體或特定攝影機看到的物體，呈現出模糊的效果。該專案網站可下載 Blender 2.65 的 Windows、Mac OS X、Linux、FreeBSD 版本，程式碼採 GPLv2 授權。該專案的開發由非營利的 Blender 基金會所贊助。

相關網址：

1. 煙霧為 Blender 2.65 帶來了火焰
http://www.h-online.com/open/news/item/Smoke-brings-fire-to-Blender-2-65-1766405.html
_______________________________________________________________

■ [源碼新聞] 令人震驚：Android SDK 二進位檔案仍是私有軟體

謝良奇／編譯

最近歐洲自由軟體基金會網站上的一篇部落格文章在網路上迅速流傳，由於下載 Android SDK 時，用戶必須同意顯然不相容於自由與開放源碼軟體的條款與條件，文章作者 Torsten Grote 因此宣稱該軟體已經是私有軟體了。但 Grote 並未提到兩件事，第一，這些條款一直都存在，還有就是，這些條款僅用於 SDK 二進位檔案。存取其原始碼依舊是開放的。

Android SDK 上的條款與條件包含了不相容於自由與開放源碼軟體的若干限制，像是防止分支的反分裂條款。這些條款許多早已存在多年，並不是新聞了，Android SDK 的確是私有軟體，而且一直都是。

隨著該文章在網路上流傳，卻有一個關鍵之處很容易被忽略，那就是這些條款僅適用於 SDK 二進位檔案。採用 Apache 2 授權的原始碼仍然可自由取用，因此用戶自行編譯 SDK 後就可以迴避 SDK 的條款。Replicant 就是這麼做的，你也可以下載他們從 原始碼編譯好的最新版 SDK (API level 15)。

Android 的情況，包括其開放源碼的本質，Google 加諸於 Android 品牌上的授權與限制，一直以來都是誤解的來源。因此出現像這樣的複雜問題是可以預料的。最簡單地說，在 Apache 2 與 GPLv2 授權下的 Android 程式碼是開放源碼，但 Google 所擁有的應用程式套件則不是。

為了掛上 Android 這個名牌，你得遵守一些相容性要求。雖然這與 Android 原始碼完全不相干，人們卻經常將其混為一談。更加複雜的是，Android 裡面有些程式碼，主要是不為 Google 所擁有的驅動程式，並不是開放源碼。

為品牌加諸額外要求一事，在開放源碼界不算罕見。例如，Haiku 基本上採取了相同的做法。作為開放源碼專案，雖然任何人皆可自由使用 Haiku 中的程式碼，但由 Haiku 公司所擁有的 Haiku 商標，就無法以相同方式自由地為人取用。更有名的例子是 Red Hat，其 Linux 散佈套件也運用了此做法。

在 SDK 二進位檔案上加以額外限制，儘管並不自由或開放，卻不會對 Android 的私有性有所增減。因為任何人都可以下載並使用其程式碼。當然如果 Android 的開發能採用開放模式會更好，但並不是一定得這麼做不可。

可以猜想得到的是，這個故事會以各種形式持續時不時的出現，由渴望流量的部落客，以及對開放源碼運作了解甚少或毫不了解的人延續下去，就好像網路上一長串重複出現的其他主題一樣。


相關網址：

1. 令人震驚：Android SDK 二進位檔案仍是私有軟體
http://www.osnews.com/story/26666/Shocker_Android_SDK_binaries_still_proprietar
_______________________________________________________________

■ [源碼新聞] 三個你沒聽過的 Linux 散佈套件

謝良奇／編譯

這個週末何妨瘋狂一下，嘗試一下最另類最低調的 Linux 散佈套件？以下是三套少為人知的散佈套件。

Hanthana Linux (http://www.hanthana.org/)

Linux 正進入全球各個角落，創造私有軟體商絕不會感興趣的機場。Hanthana Linux 是斯里蘭卡 Hanthana 學校實驗室專案的一部分，Hanthana 專案的目的為：集合社群共同幫助並改善斯里蘭卡農村地區的 IT 教育。"知識就是力量"，我們強烈相信所有的斯里蘭卡學子都能取用功能齊全的電腦實驗室。

Hanthana Linux 是以 Fedora 為基礎，加上額外的 codecs 多媒體播放器，由 live DVD 執行，也能安裝到硬碟上。Hanthana 背後的社群正巧妙地運用 Linux 和開放源碼：網站架設在 WordPress 上，他們也利用了 Twitter 與 Facebook 等採用 Linux 和開放源碼的社群媒體。

ROSA Linux (http://www.rosalab.com/)

ROSA Linux 以 Mandriva 為基礎，並有著高度客制化，更加精簡的簡化版 KDE4 桌面。ROSA 還維護了一套 Red Hat 與 Mandriva 為基礎的伺服器版本、給教師的 ROSA 課堂伺服器、ROSA Sputnik 車輛資訊娛樂系統。車用 Linux 正發了狂似的成長，為什麼不先來個預覽呢？

Cinnarch (http://www.cinnarch.com/)

有許多以 Arch Linux 為基礎的散佈套件即將到來，Cinnarch 看似可作為時尚且典雅桌面一個很好的選擇，它採用 Cinnamon 桌面、絕佳的 lightDM 顯示管理器，和 Arch 一樣採滾動式發行 (rolling release)。外觀與排版高度可客制化，看來簡單漂亮。


相關網址：

1. 週末專案：你沒聽過的 Linux 散佈套件
https://www.linux.com/learn/docs/680406-weekend-project-linux-distros-you-never-heard-of/
_______________________________________________________________

■ [源碼新聞] Wikipedia 漸採 MariaDB 來代換 MySQL

黃郁文／編譯

LAMP 是近年一個常見的縮寫，它指的是以 Linux 為作業系統、Apache 為網頁伺服器、MySQL 為資料庫管理系統，最後則選擇 PHP、Perl，或是 Python 為專案的程式碼撰寫語言。這樣的組合由於使用的都是自由開源授權的軟體元件，所以使用上非常的穩定、廉價而達到普遍。而從這樣的縮寫可知，多年來，MySQL 一直是最受歡迎的自由開源資料庫管理系統，不過近來後起之秀，也就是 MySQL 的分流 MariaDB 急起直追，甚至連 Wikipedia 這個全球最大的網路共筆創作網站，都開始階段性地選擇揚棄 MySQL，轉而投入 MariaDB 的懷抱！

MariaDB 是 MySQL 創始人 Michael Widenius，在 Sun 於 2008 年買下 MySQL 後，續行採用 GPL-2.0 授權，另起爐灶分流開創而成的版本，一直以來 MariaDB 承襲過往 MySQL 舊版本的既成基礎，不乏有來自社群界與商業界的服務客戶，並持續地不斷發展。再加上近年，自由開源軟體社群對於 MySQL 從 Sun 再為 Oracle 收購之後，逐年調高商業版本的授權費用，並提高程式源碼獲取的門檻與難度，顯示 Oracle 有意讓 MySQL 朝向封閉系統發展的傾向相當不滿，在這層因素下，更加擴展了 MariaDB 作為 MySQL 完全替代方案的可能性。維運 Wikipedia 的 Wikimedia Foundation 網站架構師 Asher Feldman 表示，之前他們便在英文版 Wikipedia 的部份分站進行代換的試驗，將原本的 MySQL 資料庫，改用 MariaDB 5.5.28 版本進行運作，更在 2012 年底完成多數英文版 Wikipedia 的系統代換，而進一步的，更將在 2013 年的春季完成 Wikipedia 全體的代換工程。

而究竟 Wikipedia 為何琵琶別抱？Asher Feldman 指出從技術面來看，使用 MariaDB 比起時興的 MySQL 5.1 版本，其效能與穩定性並沒有顯著差異，從 Wikipedia 英文分站的測試數據來看，一般條目的搜尋效率加快了 8%，特定的條目甚至快上 10-15%，雖然也有部份的條目呈現 3% 的遲緩值，但也並沒有其他嚴重的不正常反應，若整體以每秒查詢總效率來分析，則網站在查詢表現上提升約 2-10%，算是一個非常成功的試驗。而另外與技術表現無關的，就是為了 Wikimedia Foundation 及整個自由開源軟體社群的權益，是該選擇與授權政策明確穩定的 MariaDB 基金會來合作，以確保資料庫科技未來的永續開放性。


相關網址：

1. Wikipedia 離開 MySQL 擁抱 MariaDB
http://www.zdnet.com/wikipedia-moving-from-mysql-to-mariadb-7000008912/

2. 英文版 Wikipedia 採用 MariaDB 5.5 進行運作
http://permalink.gmane.org/gmane.science.linguistics.wikipedia.technical/65729

3. 開源分支專案 MariaDB 挑戰 Oracle
http://www.zdnet.com/open-source-mariadb-a-mysql-fork-challenges-oracle-7000008311/

4. MariaDB 授權聲明頁面
https://kb.askmonty.org/en/mariadb-license/
_______________________________________________________________

■ [源碼新聞] Linux 基金會提供 Android 開發課程

謝良奇／編譯

Android 應用程式開發引起了 Linux 基金會的興趣。目前 Linux 基金會培訓網站的 Android 開發培訓包含了三種課程：

Android 簡介：為期三天的課程會教授 Android 應用程式開發的基礎。此課程將協助你迅速開發可在不同裝置上運作的 Android 應用程式。

深入 Android，簡介 Android 內部機制：為期五天的課程將帶領你深入走訪 Android 作業系統，包括 Bionic 程式庫、Wakelock 電源管理架構、Binder 跨行程溝通、Dalvik Java 虛擬機器。同時也針對將 Android 移植到新硬體所需的 Android 建構系統設定及程序，提供循序漸進的指引。

Android 訓練營：該課程同樣為期五天，將教授以 Eclipse 為基礎的 Android 開發工具、Android SDK、Android 所有基本與進階功能和 API，像是背景服務、加速度計、圖形、GPS。此外還將比較 Android 與其他平台。

根據 Android Central 的說法，雖然你學不到如何開發下一個憤怒鳥，但你所獲得的一些指引與基本資訊，將可引領你往打造屬於自己的應用程式邁進。


相關網址：
1. Linux 基金會提供 Android 開發課程
http://www.muktware.com/5058/linux-foundation-intrested-teaching-android-development#.UPNoDWdOtws
_______________________________________________________________

■ [源碼新聞] LibreOffice 4.0 Beta 已釋出為馬拉松測試準備就緒

謝良奇／編譯

文件基金會 (The Document Foundation) 已釋出 LibreOffice 4.0 的第一次 beta 版本，為長達 6 天的國際性測試馬拉松準備就緒。LibreOffice 4.0 穩定版預計在 2013 年 2 月會推出。為了給 beta 測試一個好的開始，在這個從 12 月 14 日起跑為期 6 天的測試活動中，用戶預期將找出、報告程式錯誤並通知開發者。這場測試馬拉松的佈告介紹參與這次活動會是簡單又好玩的，由於活動持續一周，每個人都可以選擇適合自己的最佳時間點。

LibreOffice 4.0 的改動相當廣泛，其中對 LibreOffice 核心最重要的是加入 CMIS 支援。CMIS 是存取開放標準協定，可用以存取內容管理系統如 Alfresco、Nuxeo、Sharepoint。除了增加一個在現有內容管理系統中，輕易儲存、分享、管理文件的新途徑，新的應用軟體可以實作 CMIS 為 LibreOffice 提供管理儲存。

此外還有許多小的改動。在 Writer 中，加入了匯入 DOCX ink annotation、匯入匯出原生 RTF 數學表達式的功能，並且無需建立頁面樣式即可在第一頁放置不同的頁首與頁尾。Calc 在試算表函數中新增了 XOR，加快了文件匯入，並且多了供期權定價使用的定價附加元件 (Pricing Add-in)。Impress 改進了媒體預覽效能，並多了記住側欄狀態的功能。Draw 則提升了頁面預覽的品質。

至於資料庫元件 Base，將可在非 Windows 平台上取用 Thunderbird 的通訊錄。LibreOffice 程式碼減少了 Java 的使用，提供更好的 Visio 匯入功能，以及 Microsoft Publisher 的匯入過濾器。其他更多改動詳述於釋出說明中。LIbreOffice 4.0 Beta 授權採 LGPLv3，已可供下載。


相關網址：

1. LibreOffice 4.0 Beta 已釋出為馬拉松測試準備就緒
http://www.h-online.com/open/news/item/LibreOffice-4-0-Beta-released-ready-for-a-marathon-test-1765275.html


_______________________________________________________________

■ [源碼新聞] Freescale 等公司加入 Linux 基金會

謝良奇／編譯

Linux 基金會宣布 5 個新會員的加入，其中包含嵌入式處理器製造商 Freescale。Freescale 表示 Linux 基金會主管了重要的嵌入式成果，像是 Yocto 專案以及和 OpenEmbedded 的合作等。因此參與其中並增加對此體系的貢獻，可說是再自然不過的了。同樣加入該基金會的顧問公司 Amarula Solutions，會為該社群帶來他們在 Linux 核心中，主線化修補程式、驅動程式、機器層程式碼的豐富經驗，同時他們也在尋求更廣泛的合作。

在香港上市的 SIM Technology，是手機與無線通訊設備開發商，此次也加入 Linux 基金會，該公司執行長表示，Linux 是嵌入式設備作業系統無可爭議的領導者。另外兩家公司則是 Superb Internet Corporation 與 Symphony Teleca Corporation，分別是虛擬主機與軟體即服務供應商，以及系統整合與服務公司。

Linux 基金會表示，嵌入式開發與雲端運算兩大領域，2013 年預期將加快發展步伐。鑒於市場正快速轉向手持裝置與以網路為基礎的分散式服務，此一預測並不令人意外。值得關注的是，該基金會如何匯集需求迴異的嵌入式設備製造商與資料中心業者。


相關網址：

1. Freescale 等公司加入 Linux 基金會
http://www.h-online.com/open/news/item/Freescale-and-others-join-Linux-Foundation-1766743.html
_______________________________________________________________

■ [接案／工作] 自由軟體鑄造場 - 誠徵「工讀生」

ROCK／文

【職　　務】工讀生
【需求人數】1名
【工作內容】交辦事務處理，例如︰影像處理、網頁編輯、資料整理...等等
【學歷要求】專科以上（夜間部佳）
【工作經驗】不拘
【工作地點】11529 臺北市南港區研究院路 2 段 128 號 402 室（中央研究院 資訊科學研究所）
【必備條件】

    ◎具電腦基本操作能力
    ◎需具備HTML語法編輯能力
    ◎英語能力具一定的基礎
    ◎負責任的工作態度，以及有學習意願者佳

【工作待遇】時薪 110 起
【工作時段】每週安排約 2~3 個工作天（09:30～17:30）
【加分條件】符合工作必備條件並領有直轄市、縣（市）主管機關核發證明之身心障礙者。
【應徵方式】

    請檢附履歷、基本資料（學經歷、照片、可安排之工作時間、聯絡方式等），寄至 rockhung@citi.sinica.edu.tw ，洪先生收，標題請註明：應徵工讀生。將擇優通知面試，不適任者恕不退件及函覆。
_______________________________________________________________


□ 關於本報 □__________________________________________________

◎ 主編︰洪華超
◎ 法律專欄編輯︰葛冬梅
◎ 技術編輯︰曾義峰
◎ 執行編輯︰王怡凱、林誠夏、林珈宏、陳蕙蓁、彭冠雯
◎ 外稿編譯︰黃湘婷、黃郁文、蕭惟杰、謝良奇

本電子報自行採訪、報導、編譯、撰寫文章之智慧財產權屬於中央研究院，採用創用 CC「姓名標示－禁止改作－非商業性」授權條款臺灣 3.0 版授權散布，歡迎在不變更內容的前提下，以任何形式重製與散布本報，但必須遵守下列義務︰（1）不得為商業目的之利用；（2）必須標明本電子報智慧財產權屬於中央研究院；（3）完整引用本著作權說明。

若欲以創用 CC「姓名標示－禁止改作－非商業性」授權條款臺灣 3.0 版以外的方式利用上述文章，請與自由軟體鑄造場編輯群（ossfepaper at openfoundry.org）聯絡。

非自由軟體鑄造場自行撰寫的單篇文章，其智慧財產權利屬於原作者所有，其以非專屬的方式授權予自由軟體鑄造場運用，而與本電子報其他文章併以創用 CC「姓名標示－禁止改作－非商業性」授權條款臺灣 3.0 版的方式進行散布。

若欲以創用 CC「姓名標示－禁止改作－非商業性」授權條款臺灣 3.0 版以外的方式利用個別作者的文章，請自行與該作者聯繫，或透過自由軟體鑄造場編輯群（ossfepaper at openfoundry.org）來轉發聯絡訊息。

授權條款全文請見︰
http://creativecommons.org/licenses/by-sa/3.0/tw/legalcode
授權條款簡介請見︰
http://creativecommons.org/licenses/by-sa/3.0/tw/deed.zh_TW

若欲訂閱本電子報，請至以下網址︰
http://www.openfoundry.org/tw/news

如欲取消訂閱這份電子報，可透過自由軟體鑄造場新聞首頁左上方之自動退訂機制︰
http://www.openfoundry.org/tw/news

或寄發電子郵件至︰ossfepaper@openfoundry.org，以進行人工退訂。
