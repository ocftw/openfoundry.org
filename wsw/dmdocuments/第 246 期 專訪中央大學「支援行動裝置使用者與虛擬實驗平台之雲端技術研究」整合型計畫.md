___
 
□■□ 自由軟體鑄造場電子報第 246 期 | 2014/07/29 □■□
___
 
◎ 本期主題︰ 專訪中央大學「支援行動裝置使用者與虛擬實驗平台之雲端技術研究」整合型計畫
 
◎ 訂閱網址︰[http://www.openfoundry.org/tw/news/](http://www.openfoundry.org/tw/news/)
 
◎ 下次發報時間︰2014/08/12
 
#本期內容#
___


##[源碼專案] 專訪中央大學「支援行動裝置使用者與虛擬實驗平台之雲端技術研究」整合型計畫##

四貓／文

進到捷運車廂，抬頭一望可以發現幾乎「人手一機」，有的人拿著智慧型手機使用即時通訊軟體、有的人拿著平板看電視，「低頭族」的名詞也應運時代而生。當行動裝置成為最普遍的雲端服務存取裝置之一，除了便利之外，其實也悄悄地帶來一些資安風險，因此，如何提昇行動裝置的安全性便成為當前許多開發者的關注焦點。中央大學的「支援行動裝置使用者與虛擬實驗平台之雲端技術研究」計畫便是利用雲端環境進行資訊安全的研究，並將研究內容分成三個子計畫，今天 OSSF 特派員四貓很榮幸訪問到這些計畫的主持人，中央大學的梁德容、陳奕明和王尉任老師，現在就立刻帶大家一起來看看這些計畫在做些什麼有趣的事情吧！   

###[雲客端—手持行動裝置使用者識別機制](http://www.openfoundry.org/of/projects/2309)

不知道大家有沒有過遇過這樣的情境：拿出手機想要和朋友分享有趣的照片，但是一群人圍上來看你輸入手機的解鎖密碼…是不是有點尷尬呢？現在以智慧型手機為主流的手持行動裝置，不僅僅可以通話，更可以隨時存取雲端服務，讓生活更加便利，但享受便利的同時也帶來新的資安議題：「手持行動裝置與雲端服務現存安全機制是否足以維護存取雲端服務上隱私與敏感性資訊的安全？」

目前的智慧型手機通常是以 PIN 碼、密碼、圖形鎖為主，也有採用指紋或臉部等生物特徵的識別技術。然而，密碼與指紋這類型的安全性機制皆需要使用者執行一個特定的認證程序，屬於侵入式驗證的方式，手續較為複雜，因此有許多用戶會因為侵入式認證的不便而～關閉該功能，但即便開啟了密碼認證的功能，還是有可能被旁人窺探，而導致隱私外洩。因此，他們團隊便以「非侵入式識別機制」作為研究主題，以增加行動裝置的安全性。根據團隊的觀察，發現使用者在抓握拿取手機的時候，每個人都有獨特的姿勢角度，而手持行動裝置內建感應器可擷取這些行為特徵，並建立一套非侵入性的使用者識別機制，代號叫「隱形二代鎖」，而雲端服務平台也可以利用像「隱形二代鎖」這樣的機制來防禦非法的存取。 

計畫的主持人梁德容老師說明：「我們都知道，現在使用智慧型手機的人很多，這些人可能利用手機到雲端平台上進行交易行為，或會拿到敏感資料。目前利用手機做的安全服務大概就是帳號密碼，但密碼被盜在手機上被竊盜的風險特別高。」梁老師解釋，這是由於手機可攜的特性，如果是桌機上的帳號密碼，除非是電腦被植入木馬，否則竊賊就要想辦法侵入房間；但手持式的裝置，別人很容易從你的身後就窺視到你的帳號密碼。現在我們面臨的環境跟傳統的運算使用是不一樣的，過去我們傳統保護安全的方法到現在可能不再適用。那解決的方法呢？老師表示隱形二代鎖正是為了彌補過去傳統識別機制的不足而開發，假設我們現在要登入某個敏感性的服務，它一方面會記住你的密碼，一方面會在你操作的過程之中，收集使用者的慣用行為來判定是不是使用者本人。由於它是藉著分析使用者慣用手的姿勢、角度以及觸控的壓力變化等行為來進行驗證，但其實人不是機器，人的行為是會有變化的，每次手持的角度即使類似但還是會有分別，或是遇到雖然不同人但行為模式接近的情況，因此技術上的挑戰在於如何降低誤判、提高辨識率，換言之，就是「如何掌握一個人多樣的行為中具有代表性的行為」而這個代表性的行為又必須和別人有所區別。   

###[具狀態回饋與互動功能之雲端虛擬實驗服務平台研究](http://www.openfoundry.org/of/projects/2311)

陳奕明老師主持的這個虛擬實驗平台，則是因應人們對網路安全教育不斷提高的需求，為了讓安全概念落實到每一個使用者和管理者，因此他們建立了一個實驗平台，老師說這個虛擬平台就好比是網路上實驗室，想要進行練習的資安人員，不用準備成套的實驗設備、不用經歷繁複的安裝過程，只要進到這個雲端實驗室就可以獲得第一手的體驗和演練的機會。這個平台的特色是「安全且具彈性」，由於本身是一個以資安訓練為主要內容的實驗平台，它本身的安全性也特別受到關注，如果平台自己遭受攻陷或一些不當利用，那勢必會降低使用者對於平台內容的信心。陳老師表示，透過另一個子計畫的協助可以防治這些問題，比如說利用認證的機制，讓使用者在操作平台的時候不會受到外界的干擾，同時也提供了隔離的防護，萬一進行一些比較危險的實驗時（例如 DDos 實驗），真的有問題產生，也馬上可以聯絡網管隔離該區域網路防止事態擴大、降低風險。他們也設置了監控的機制，如果 CPU 的使用率太高，或者網路有不正常流量的時候，都可以在第一時間進行控制。為了慎重起見，目前平台仍限於學校或相關合作學校的帳號及ip使用，但未來希望可以發展成一個人人都可以使用的虛擬實驗平台。而平台的彈性則來自於虛擬機器，雖然實體設備有限，但利用虛擬機器則可以將資源進行最大的運用。   

###[提供具高彈性化與高可用性之雲端平台研究與開發](http://www.openfoundry.org/of/projects/2313)

由王尉任老師所主持的這個雲端平台，在支援另外兩個計畫的時候發揮了很大的功效，也可以說另外兩個計畫都是這個平台的用戶。但說到雲端平台，可能有人會馬上聯想到 Iaas, PaaS, Saas，這個平台是屬於哪一個分類，這幾個平台又有什麼差別？馬上來看看王老師的說明！  

如同上面所提過的，雲端服務一般來說會分成三種類型：IaaS, PaaS, SaaS，其中 IaaS 是指 Infrastructure as a Service，是將基礎架構來當作雲端服務。所謂的基礎架構是指運算資源，包含 cpu, memory, 儲存空間等等。如果使用者需要這些類型的服務，則會使用到虛擬化 (vertualization) 的技術，也就是提供虛擬機器透過遠端連線讓使用者在雲端使用，可以在上面輕易地建立使用者想要的環境。PaaS 則是 Platform as a Service 的簡寫，它的概念比 IaaS 高一個層級，它提供的是雲端的平台。這裡的「平台」定義為要讓應用程式能在上面執行，還要有能力提供一些開發的工具、例如 API 或是 debugging, programing 的工具，這套解決方案越完整越好。如果它有對外提供服務的話，監控的機制也必須要足夠，例如有辦法紀錄使用者的使用的時數，才能準確的計算服務費用。所以 IaaS 和 PaaS 最大的不同在於平台要提供開發工具執行應用程式。最上層的 SaaS 是 Software as a Service, 它的概念就是透過標準的通訊協定和軟體溝通，即可進行操作。這種軟體可以有各式各樣的形式，舉例來說、大家常用的 Gmail 就是一個標準的 Software as a Service, 而在他們的計畫中，陳教授的虛擬實驗平台提供網路的攻防教學，也是一種 SaaS 的服務，而王老師的計畫發展的則是下面 PaaS 或 IaaS 層級的服務，兩者關係其實密不可分，底層沒有提供的功能上層就無法使用，或必須要換不同的方式來進行，由於沒辦法直接對底層網路控管，進而有可能造成安全上的疑慮。

當初發展這個計畫的概念，他們發現過去雲端在 IaaS 和 Paas 這兩個層級的服務，大部分都是考慮到單一的虛擬機器管理，但團隊在其中看到另一個需求，其實在這些計算資源管理上並不一定要侷限於一台機器，既然是虛擬的，應該更有彈性一點，例如採用虛擬叢集的概念。什麼是虛擬叢集呢？老師舉了一個例子是線上交易的服務，前端可能有 web server, 後端則有 data base 和檔案系統，這個東西串起來就是一個虛擬叢集，彼此之間會有頻繁的通訊，如果能將這樣的叢集變成一個範本，從中去衍生各種虛擬叢集的服務，也能夠快速部署已經建置好的虛擬叢集。另一個例子是最近 OpenStack 有一個名為 Sahara 的新計畫，它其實也帶入了虛擬叢集的概念，上面有進行大量資料管理系統所會用到的一些分析工具，它提供了 OpenStack用戶快速部署、啟動 Hadoop 叢集的解決方案。但王老師希望可以更加提昇電腦運算的智慧，除了監控實體機器的使用率之外，他們還會去監控虛擬機器之間的關係，看虛擬叢集間的機器是不是真的有密集的聯絡，因為被設定成同一個虛擬叢集的時候，我們會預期這些機器間應該有頻繁的溝通。收集這麼多各式各樣的數據，其實都只為了一個目的：找出最佳的解決方案。在虛擬機器、虛擬叢集上面，還能進一步發展成虛擬資料中心 (Data Center), 進行更大規模的支援。


看完了這三個台灣開放原始碼的專案，是不是覺得都很創意也有趣呢！趕快來看看這些專案的頁面唷！
* [雲客端—手持行動裝置使用者識別機制](http://www.openfoundry.org/of/projects/2309)
* [具狀態回饋與互動功能之雲端虛擬實驗服務平台研究](http://www.openfoundry.org/of/projects/2311)
* [提供具高彈性化與高可用性之雲端平台研究與開發](http://www.openfoundry.org/of/projects/2313)
___


##[法律專欄] 淺論程式源碼與目的碼在自由開源軟體授權條款裡的同與異##


葛冬梅、林誠夏／文


程式源碼 (Source Code) 與目的碼（Object Code，註一）是軟體程式存在的兩種基本型態，前者指的是電腦程式可供後續增編修改的格式，有時可被直接執行，但多半時候必須經編譯或界定程序之後才能被執行，後者則是能夠直接供電腦機器判讀的執行檔格式，但因已經過編譯程序，故除非經過反組譯或是還原工程，否則一般人無法直接觀察目的碼，來了解該電腦程式的演算過程及運算邏輯 (algorithm)。一般來說，軟體程式可以擇一或是同時透過這兩種型態來被散布，就法律論理上，其在著作權法上是被視為是同一作品不同形態的表現，故其表現形式雖不同，但法律定位完全相同。過去電腦程式目的碼是不是能受到著作權法保障是有疑慮的，畢竟這樣的著作格式並不如同一般受著作權保護的客體：詩、詞、書、畫、文章、音樂、電影般，能被直接閱讀、聆聽、感受，和了解，不過美國於 1983 年 Apple Computer, Inc. v. Franklin Computer Corp. 一案中，承審法官在反覆的論理之後，判定目的碼亦為美國著作權法保護的客體之一，同時，因其無法為人類直接了解之故，更進一步認定其與程式源碼具有同一性關係（註二）。此一判決也影響其他各國就此議題的認識，此後多數法律見解皆偏向於將程式源碼與目的碼，視為電腦程式的一體兩面，故表現的方式雖有差異，但被著作權法保護的本質與地位相同。這樣的解讀態度適用在一般私有軟體 (proprietary software) 上，固然不會有太大的問題，畢竟私有軟體在授權使用上的基本規則為「權利人保留所有權利 (all rights reserved)」，故使用他人電腦程式時，未經授權方同意的方式，基本上都是不被法律所允許的，然而，許多的自由開源軟體 (Free and Open Source Software) 專案及其授權條款，蘊含著一種盡量將程式源碼提出來讓後手使用者增刪修改並便利應用的態度，故在其授權條款中，可以看到許多的內容是明確地針對程式源碼或目的碼所作的，略有差異的義務性要求，此項特點多為一般使用者所不知或忽略，而這方面的資訊，也正是本文希望透過特定條款的例示與說明，所要傳達給大家的。


###【多數的自由開源軟體授權條款仍將程式源碼和目的碼進行一致處理】###


就比例來看，自由開源軟體授權條款中的程式源碼與目的碼，在義務規定方面具有處理上的一致性，仍是大多數的常態，例如一般最容易被使用者認識到的 BSD 授權類別，以及 GPL 授權類別，就還是維持這樣的基本態度。以 BSD 類別這一系列條款為例，其中最基本的義務規定是：使用者在散布程式源碼的同時必須保留原程式的著作權聲明、義務條款內容以及免責聲明。故當使用者採取透過目的碼形式散布軟體的時候，上述這些文字聲明也可能會被編譯成為無法閱讀的目的碼，因此 BSD 系列條款規定，使用者必須重建上述的文字內容，讓取得目的碼的後手，一樣可以在合理的狀況下閱讀到這些聲明（註三），而若達到此一標示義務，基本上就 BSD 授權類別來說，就已完善地達到程式源碼與目的碼一致的義務性要求。可以說，BSD 授權類別的自由開源軟體專案，程式的釋出者奉行的是一種「求名以聞達」並讓使用者在「最低義務限制」下運用軟體的態度，故對於程式源碼和目的碼並不會刻意作差別化的處理，只要使用者就源碼格式或目的碼格式的散布，都能善盡原始作者的顯名要求，即可。


另外，以 GPL 這一系列條款的自由開源軟體授權條款為例，因其設置的主要目的是維持程式源碼的流通，與便利後手的改作。故本質上 GPL 授權類別更是將程式源碼與目的碼視為完全相同的一件事，並要求當程式目的碼被散布的時候，使用者也必須要提供其「相應完整的程式源碼 (corresponding source)」給予後手，為此，GPL 系列條款便規定：修改後所產生的衍生程式 (derivative work)，無論呈現的方式是程式源碼格式還是目的碼格式，其散布時必須要繼續採用相同的授權條款來提供，所以當使用者要散布衍生程式目的碼的時候，也一樣必須依照 GPL 系列條款的規定，來提供衍生程式的程式源碼。這種為了維持程式源碼的流通，而規定衍生程式的程式源碼與目的碼，均必須繼續採用相同授權條款來散布的規定，正是源碼義務與目的碼義務一致性呈現的最佳範例。


###【少數條款中程式源碼與目的碼義務規定有著極大的差異】###


不過並非所有的自由開源授權條款，在程式源碼與目的碼的義務規定上，都具有著完全的一致性，少數的自由開源軟體授權條款，對程式源碼與目的碼在散布上的運用方式與義務性規定是有許些差異，這讓使用者在散布軟體程式的時候，有機會因為散布軟體型態的不同，而可以依循不同的規定，進而產生完全不同的運用效果。究其要理，這是因為當前自由開源軟體的推動，已不再是以單純社群分享理念、或學界顯名態度為唯一的推動動機，近年大型的自由開源軟體專案，背後多有商業公司的資源與力量浥注，故不少此一性質的參與者，試著將其調合開源分享模式與便利商業運轉的想法，編寫至其所運用的自由開源軟體授權條款裡，以下所例示，由 Apache Software Foundation 編撰，為 Google Inc. 於各專案大力採用的 Apache License, Version 2.0 (Apache-2.0)，以及微軟 (Microsoft Corporation) 所編撰與推行的 Microsoft Public License (MS-PL) 即為著例，此二條款就程式源碼與目的碼的散布型態，便有著寬嚴不一的區別處理。


以 Apache-2.0 這份條款為例，第 4 條第 c 款規定，使用者散布修改後衍生程式的程式源碼時，必須保留原程式中的各項聲明，但是當散布衍生程式的目的碼時，卻沒有完整重建這些聲明細節的義務（註四），僅要求目的碼格式的融合與使用，必須給予後手一份 Apache-2.0 授權條款全文或與 Apache-2.0 義務性規定完全相容的其他條款全文，標註哪些原 Apache-2.0 授權檔案已被修改或更動，並保留與適當調整原 Apache-2.0 專案裡 "NOTICE" 檔案裡的相關資訊即已足。這樣的規定與上述 BSD 系列條款對照看來，可以了解到，Apache-2.0 對於散布衍生程式源碼的義務規定，並沒有完全連貫到散布目的碼的義務規定之中，主要的原因，可以說在商業散布與運用的環境當中，一定程度以較寬鬆的態度來便利目的碼型態的運用方式。


[https://www.openfoundry.org/images/140729/lc_201407_img1.png](https://www.openfoundry.org/images/140729/lc_201407_img1.png)
▲ 圖1：Apache-2.0 第 4 條第 c 款規定內容。


另外一個有趣的例子則是 MS-PL。這份由微軟所制定的自由開源授權條款，其在第 3 條第 (D) 款規定，當使用者以程式源碼型態散布軟體的任何一部份，這些程式源碼仍必須透過來 MS-PL 來授權，同時，使用者還必須將 MS-PL 的全文內容隨程式源碼一起附上、一起散布，來提供給程式後續的下載與使用者。但是當使用者以目的碼型態散布軟體時，MS-PL 卻允許使用者能夠為這些目的碼選擇 MS-PL 以外的條款來散布，只要所選擇的條款是符合 MS-PL 的義務性規定即可（註五）。微軟對 MS-PL 這樣的處置，主要是希望在程式源碼的格式，仍強力要求改作者必須採完全相同的授權模式，將其改作的成果提供出來，如此一來，未來微軟將可以完全不用就授權狀態進行調整，即可將外部改作者對原程式進行的修改，匯入到下一個 MS-PL 授權程式的更新版本裡，而在目的碼格式方面，由於微軟及其合作廠商的共工狀態，當前多半仍是產出商業性方案，故為了便利合作廠商未來能夠採單一私有授權來運用整體專案，故就 MS-PL 授權程式的目的碼格式，規劃了遠寬鬆於程式源碼格式的運用限制。


[https://www.openfoundry.org/images/140729/lc_201407_img2.png](https://www.openfoundry.org/images/140729/lc_201407_img2.png)
▲ 圖2：MS-PL 第 3 條第 (D) 款規定內容。


###【結語】###


電腦程式的著作權利人，針對程式源碼、目的碼兩種型態，得以再依條款內容規劃出不同運用方式的現象，相對於著作權法所保護的其他詩詞書畫等著作客體來說，是一個特殊的現象。以最典型的文章、圖畫等傳統著作來說，從開始被創作出來到完成為止，都只有透過一種形式來呈現：文章透過文字、圖畫透過顏料的色彩，因此這些傳統著作不需要被轉換成為另外一個形式，就可以被閱讀或是欣賞。但是軟體程式的開發過程是以程式源碼的形式存在，而等到要安裝、執行時，因功能性的配置或與其程式框架的配合，才去將程式源碼轉換成為機械能夠直接辨識與執行的目的碼，進而被安裝到電腦系統上來執行運作，可以說，電腦程式擁有的兩種表現型態，讓其在運用上迥異於其他的著作類型。但有趣的是，當代因數位化工具、輔具的大量運用，許多詩詞書畫、影音、多媒體等著作權保護客體，也有很大的機會是直接在電腦程式的控制下被直接編輯產生，從而有其原生數位編輯檔、以及列印呈現檔的不同儲存格式。部份國內外的論述者，已經開始就此議題展開討論，並且在商業運用的環境下，亦不少契約已經針對「編輯檔」與「列印檔」之間，律定了不同的運用模式與權限差異。


所以說，可以同時透過程式源碼與目的碼兩種型態，來產生不同的運用模式，是軟體程式，尤其是自由開源軟體領域裡的特殊之處，而雖然大部分的授權條款對於程式源碼與目的碼的運用規則，有著相當的一致性，不過仍有少數條款對於兩者有著不同的義務規定，而這股分殊化的實作與運用概念，甚至也開始擴散到數位化的其他著作權素材裡，故未來讀者在了解自由開源授權條款，或是接觸新近 3D 列印技術與實作的領域時，也可以注意此種程式源碼與目的碼運用規定不一、編輯檔與列印檔的應用要求不同的狀況，以找出最符合期待與最多益處的運用模式！


----


註一：所謂目的碼，指的是能夠直接供電腦機器判讀的執行檔格式 (binary form)，故或有稱之為「機器碼 (Machine Code)」、「機械碼」，此亦目前市面上取得私有軟體 (proprietary software) 使用授權時，最普遍存在的形式。


註二：進一步的相關分析與見解，可參閱，陳家駿、呂榮海合著，電腦軟體著作權，蔚理法律出版社，1989 年 3 月，頁 13；益思科技法律事務所，自由軟體之著作權問題研究，智慧局報告，頁 122-124，2006 年。


註三：BSD 系列條款中，目前較為常見的主要有 BSD-2-clause 與 BSD-3-clause 這兩款，而這兩款均有本段所提到的義務規定。


註四：原文截錄如右為：You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and；而在透過目的碼型態來散布原程式的情況下， Apache-2.0 則並沒有要求使用者必須重建各項聲明內容的全文，不過實務上，筆者都會強烈建議重建其中基本的著作權與授權聲明，因為自由開源軟體著作權人將軟體無償授權出來，多有期望名聲得以因此聞達的隱性目的，故若在散布目的碼時，重建基本重要聲明，可以讓原軟體著作權人與開發社群獲得其應有的名聲。


註五：關於 MS-PL 的詳細介紹請參見：葛冬梅，來自封閉陣營的 MS-PL 與 MS-RL，[http://www.openfoundry.org/tw/legal-column-list/8263--ms-pl-ms-rl](http://www.openfoundry.org/tw/legal-column-list/8263--ms-pl-ms-rl)。
___


##[自由專欄] 為什麼比 GIT 更好－－理解 Mercurial 版本管理系統##
 
林雪凡╱文
 
（本文寫作於 2014 年 7 月，所有相關論述均以此時間點為準）
 
[Mercurial](http://mercurial.selenic.com/) 是一款分散式的[版本管理](http://zh.wikipedia.org/wiki/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6)軟體。
 
所謂版本管理軟體，是一種可在程式開發過程中，有規律地保留程式碼的歷史訊息、讓人能放心地做各種開發實驗，並在開發不幸走進死胡同時，將程式碼回復到舊有版本的系統……
 
細節很複雜，一言以蔽之，就是一種程式碼管理器。詳細說明網路上可以找到很多，我就不在此囉唆贅述了。
 
Mercurial 經常被拿來和另一款同類軟體 Git 比較，然而不知是故意貶低或缺乏了解，大部份能在網路上讀到的中文文章，都傾向於認為 Mercurial 比 Git 弱小、彈性差、功能低落，甚至只是個「教學用軟體」。但隨著我同時跨足使用這兩套系統後，我發現實況卻非如此－－甚至大部份時候都是反過來的。
 
Mercurial 沒能得到它該有的評價，這十分可惜。是故我決定撰文將輿論平衡一下，以餉讀者。
 
原則上，凡本文提到的特性，無論是 Git 或 Mercurial ，咱都有親自實驗過，各位大致上能夠安心閱讀。
 
一如題目所言，這篇文章是兩者的比較文，本文將以版本管理使用者的角度來說明，為什麼 Mercurial 比 Git 更好？
 
###先從相對 Git 的弱點開始說起……###
 
做人要實在，優點等會兒再說，先從 Mercurial 的弱點開始說起好了。
 
####**跨平台時的檔名編碼**####
 
Mercurial 現在主要的弱項在於跨平台時，處理非英文檔名可能會有編碼問題。
 
稍微強調一下：
 
* 如果只在同一種平台上進行開發則不會有任何問題；
* 如果檔名只用英文也不會有問題；
* 並非用了非英文檔名就不能跨平台，而是要看平台支援性。
 
總地來說，即使您在源碼庫中用了中文檔名，只要您的開發平台都是 utf8 的，就不需要擔心這件事。
 
相關說明請見：[http://mercurial.selenic.com/wiki/EncodingStrategy#Overview](http://mercurial.selenic.com/wiki/EncodingStrategy#Overview)
 
####**Git 的用戶較多**####
 
如今用 Git 的人比較多（特別是在中文圈中），對於開發者來說，和他人合作時碰到 Git 的機會比較大。
 
不過話說回來，Mercurial 的社群也絕不算小。您可以在網路上找到大批用 Mercurial 維護的專案，從 OpenJDK、Python、Go、Nginx、Vim 等多不勝數。其中 Nginx 是全球市佔率超過 20% 的網站後端，平均您每看五個網站就有一個是用 Nginx 跑起來的，而如果只算前 10000 個受歡迎的網站，這個比例甚至可以上升到 40 %；而 Vim 就更不用提了，他甚至永久影響了全世界程式設計師的文化體系。
 
在 [http://stackoverflow.com](http://stackoverflow.com) 中，我們能查到幾乎所有能想像得到的，關於 Mercurial 的討論與情報。總之社群支持度無需擔心。
 
####**檔案重命名的處理方式很愚蠢**####
 
受限於 Mercurial 早期的資料結構限制，如果您將檔案重命名，或僅僅只是變更檔案放在原碼庫中的路徑，則原碼庫中會產生一份額外的副本，消耗兩倍的硬碟空間。
 
這蠢死了。聽說 Git 就沒有這種問題（儘管我沒試）。
 
這個缺陷讓人心情不爽，不過話又說回來，如果您沒在倉庫中堆滿一堆巨大的二進位檔案，又三天兩頭搬動它，也不會造成什麼很嚴重的問題。
 
 
###為什麼要選 Mercurial？###
 
儘管有以上這些瑕疵，Mercurial 仍然是一款棒呆了的版本管理系統，因為 Mercurial 有著足以抵消上述一切缺陷的眾多性感特徵。我馬上就會和各位說明。
 
本文主要的比較對象是 Git，這篇文章才剛開始呢。
 
####**Point1 - Mercurial 擁有更優秀的分支模型**####
 
**1.1. 分支分離**
 
請看以下分支圖：
 
![Alt text](1.1. 分支分離)
 
用戶下命令「請分別列出 Branch 1 與 Branch 2 中含有的提交」時……
 
Mercurial 的回答是……
 
* Branch 1 -> A, E
* Branch 2 -> B, C, D
 
Git 的回答是……
 
* Branch 1 -> A, B, C, D, E
* Branch 2 -> A, B, C, D
 
毫無疑問 Mercurial 的答案才是您想要的。
 
（請想像一下 branch 1 是穩定分支，而 Branch 2 是某功能分支的狀況）
 
這不是 Git 用戶下錯指令，事實上，Git 從資料結構層面就沒辦法紀錄 Mercurial 在上述問題中所能提供的訊息。GIT 就是做不到。（註一）
 
**1.2. 保留但隱藏分支**
 
Mercurial 可以「關閉分支」，但 Git 則否。
 
在 Mercurial 中，被關閉的分支預設不會出現在分支列表裡，因此 Mercurial 可以在**不砍任何分支的前提下**，確保分支列表清爽好管理。此外，因為分支資料依然存在，所有分支都能在必要時刻被完整召回。
 
反之，Git 不能將分支封存起來。要嘛砍掉，要嘛任由分支曝露在外。想讓兩者並行，它就是做不到。
 
換個方式問，如果不去刪分支呢－－用戶能處理一個擁有一千個分支項目的列表嗎？嗯，[馮紐曼](http://zh.wikipedia.org/wiki/%E8%AF%BA%E4%BC%8A%E6%9B%BC)大概可以吧，反正我不行就是了。當 Git 用戶得意地說他們的分支很廉價可以隨創隨刪時，他們同時也是在說，**Git 絕大部分的分支無法被保存下去**。
 
不管用哪種分支模型進行開發，我們總有些時候想保留不再使用的分支－－有時甚至想保留住大部分的分支資訊，然而 Git 並沒有給我們這種選擇權。為了管理，我們非砍它不可。（註二）
 
**1.3. 毫不遜於 Git 的輕量性分支**
 
有些用戶誤以為 Mercurial 的分支比較笨重遲鈍，而 Git 的分支比較輕，但事實上絕非如此。
 
Mercurial 的分支 (branch)，與 Git 中的 branch 不同，不是將標籤紀錄在頭部，而是在「每個提交」中紀錄一個「這個提交屬於哪個 branch」的訊息標籤，每次提交時因此額外消耗的容量充其量就幾十 bytes 而已，這顯然不會對速度與硬碟容量造成任何負面影響。
 
反過來說，這種作法帶來的直接好處，您可以在前文「分支分離」段落中看到。
 
此外，Mercurial 也支援 Git 式的分支模型－－也就是將標籤記在單一變更集上，並隨提交而自動往前推進的方式。**這種類似 Git 運作方式的分支，在 Mercurial 中被稱為 bookmark**。
 
如果用戶希望，Mercurial 也可以以 Git 用戶慣用的方式，單獨運用 bookmark 分支，甚至混用 branch 與 bookmark 兩種分支方式－－比方說，branch 產生的分支可用在大家共享的大工程上，而 bookmark 類型的分支標記則留在本機供自己使用（bookmark 同樣可以推送給其他人，但預設不推送，這和 Git 一樣）。同時使用這兩者不會產生絲毫衝突，而不甩其中一方，單用其中一種分支方法也毫無問題，這僅僅只是不同專案的分支習慣不同而已。
 
反過來看， Git 則無法以 Mercurial 的方式進行分支，它從根本上就沒辦法。  
 
**1.4. Mercurial 的分支不能刪**
 
有人宣稱 Mercurial 的分支 (branch) 不能刪除，這是它用起來得小心翼翼，感覺很「重」的原因。
 
嗯，這點倒是沒錯，Mercurial 的 branch 確實是不能刪的。但這有什麼不好嗎？對於 Mercurial 而言，分支 (branch) 就和變更集本身一樣，是版本庫中不可分割的重要訊息。Mercurial 的分支訊息是版本庫的一部份，而不是像 Git 那樣僅僅把它當成某種「外加」的東西－－Git 的分支訊息與歷史無關，隨時想插就插想拔就拔，刪掉找不回來也無所謂。
 
認真對待 branch 歷史是 Mercurial 的核心設計邏輯，這和 Git 完全不同。
 
有時候，這種設計邏輯無法滿足用戶對臨時分支的要求，但別擔心，Mercurial 也允許例外。
 
如果您想在 Mercurial 中隨手建立一些幾天後就不再需要的暫時性分支，或您就是不想永久錄下分支資訊，您應該要用的是 Bookmark，若用分支 (branch) 就是用錯了工具。因為很重要所以再重複一次：**如果您覺得某些分支訊息不重要（或僅僅在某些時候覺得不重要），沒那個意思將分支訊息永久保存下來的話，您應該要用 bookmark，而不是 branch**。
 
只是，我建議您再多考慮一下用 branch 永久保有分支資訊的好處。雖然您不能刪它，但就算您搞出了 10000 個分支那又怎樣？它又不會咬你。
 
**1.5. 匿名的超輕量分支**
 
受益於強大的變更集定位能力（見後），Mercurial 中還有比 bookmark 分支更輕量的分支方式存在－－也就是**「匿名分支」**。
 
![Alt text](1.5. 匿名的超輕量分支)
 
▲當 A, B, C, D 提交路線已經完成後，退回 B，再進行一次提交，就會自動產生一個 E 分支。
 
如果用 Mercurial 進行以上操作，技術上來說 ABCDE 都會處於同一個 branch（指 Mercurial 中的 branch，見前文說明）中，換句話說一個 branch 中可能有兩個以上的「頭部 （此例中為 D 與 E）」。其中變更集 E 是最後加入倉庫的，所以切換到這個 Mercurial branch 時，預設會切到 E 版上。這時另一邊的 D 就被視為一個沒有標記的「匿名分支」。
 
您可以把 E 重新合併回 D，或是乾脆就這樣把 CD 變更集放棄繞過去，改為沿著 E 路徑繼續開發。這不需要額外處理，只要修改想修改的地方後直接提交就行，非常輕鬆。
 
與 Git 相比，Git 也能如上這樣僅靠提交產生新的頭部，但用戶幾乎無法追蹤它（除非記住 hash 值），一旦沒取名又跳離了它，很難再把它找回來，不但沒有實用性反而更像是一種操作錯誤的結果，如果將 Git 切到這種沒取名的變更集上工作還會給您跳警告。但在 Mercurial 中，因為 revset（見後）的強大定位能力，不取名也無妨，使用起來非常容易。儘管因為匿名分支沒有語義標記而不適合推到遠端與他人共享，但在本地臨時修些小 bug 時依然相當好用。（註三）
 
> 註：有些 Git 用戶認為 Mercurial 的匿名分支是個危險的蠢主意，因為在 Git 用戶的觀念中這種無名分支難以追蹤的緣故。不過對 Mercurial 來說，追蹤匿名分支易如反掌，完全不是問題。
 
 
####**Point2 - Mercurial 更易於操作**####
 
**2.1. 定位變更集**
 
Mercurial 中有一系列定位變更集的作法。
 
*2.1.1. 數字序列*
 
Mercurial 可以用序列數字，如 1、3、15 來指定某個特定的提交，而不用非打 hash code 不可。
 
舉例來說……
 
    Mercurial:
            hg update 133
    Git:
            git checkout 4a9cb402d55357b534ef28f74b85ca7bb16c87ed
 
前者遠比後者簡單，也容易識別得多，至少**用戶光看數字就能認知到不同變更集之間的先後關係，以及兩個變更集的距離大致有多遠**，這在實際操作時直覺又實用。
 
另一方面，因為在實際使用中 hash code 實在很難處理，這也意味了 **Git 用戶通常是以分支為粒度進行各種操作，而 Mercurial 用戶則可以以每次提交為粒度進行操作**－－就和喝水吃飯一樣容易。
 
*2.1.2. Revset*
 
Mercurial 可以用一種稱為 revset 的語句，來幫助使用者定位**「一個或一系列」**的變更集。這種語句可以清晰地對大量變更集進行操作。
 
以下是些官網提供的例子……
 
    hg log -r "branch(default)"
    列出 default 分支中的所有變更集。
 
    hg log -r "branch(default) and 1.5:: and not merge()"
    列出 default 分支中，繼承 1.5 版變更集的後續所有變更集，但 merge 除外。
 
    hg log -r "head() and not closed()"
    列出所有未被關閉的分支末端。
 
    hg log -r "1.3::1.5 and keyword(bug) and file('hgext/*')"
    列出 1.3 到 1.5 兩個變更集之間，（在註解或用戶名等處）含有關鍵字 “bug”，且有更動過 “hgext” 資料夾下內容的變更集。
 
    hg log -r "sort(date('May 2008'), user)"
    列出 2008 年 5 月提交的所有變更集。列出時，以提交者排序。
 
    hg log -r "(keyword(bug) or keyword(issue)) and not ancestors(tag())"
    列出涉及關鍵字 “bug” 或 “issue” 的提交，且這些版本必須尚未被包含在任一個被 tag 標記過的版本中。
 
感到振奮嗎？這是當然的！從這些例子中您可看出它的無窮威力。這是 Git 難以望其項背的，Git 根本沒法做到這些，更別說如此清晰且語義化地去達成它。**正因為缺乏這種優雅的版本定位能力，Git 雖然能將資料存在版本倉庫中，但卻無法輕易拿出使用**。這是 Mercurial 的巨大優勢。
 
順便一提，revset 還可以設定 alias，您可以將複雜的長串運算整理成一個簡單的－－甚至可以加入變數的函式版本，然後隨意運用之。
 
revset 詳細語法說明請見：
 
   * [http://www.selenic.com/hg/help/revsets](http://www.selenic.com/hg/help/revsets)
   * hg help revset
 
**2.2. 清晰的指令介面**
 
Mercurial 的指令介面遠比 Git 更容易使用。
 
*2.2.1. 功能切割*
 
Mercurial 與 Git 的指令設計邏輯不同。
 
Mercurial 每個指令專注於較少的事情，並提供更多指令供我們使用，而 Git 則更傾向於用一個大指令，將一堆種類完全不同的操作框在一起，然後透過一長串參數來操控它。
 
[網路上有人](http://stevelosh.com/blog/2010/01/the-real-difference-between-mercurial-and-git/)這樣形容：**「Git 提供一柄瑞士刀，而 Mercurial 提供一間裝備齊全的廚房。」**
 
可以想見，Git 的指令設計理念，使得它每個指令文件都非常地難讀難查找，更別說因為功能混在一起，很多時候就連要查哪個指令文件都不知道。初學者哪能知道 git checkout 既可以切換分支，又能創建分支，還能復原工作目錄中檔案的舊版本……許多全然不同的操作全混在一起了。
 
請務必觀察看看 git help checkout (接近 400 行) 與 hg help update + hg help revert + hg help branch (合計 110 行) 的壓倒性差異。缺乏容易理解的介面與文件，讓用戶在使用 Git 時很容易被咬－－甚至也更容易因此讓資料在操作錯誤下意外損失掉！
 
*2.2.2. 預設提供簡打*
 
Mercurial 所有指令都有預設提供簡打，如：
 
   * hg update -> hg up
   * hg commit -> hg ci
 
Git 也能由用戶自行設定簡打。但它就是沒有內建。換個角度看，Mercurial 也能由用戶自行設定自己專屬的簡打，簡打擴展性方面並不輸給 Git。
 
雖然簡打稱不上多重要。但每天都要與之打交道的工具，一點方便就會讓人舒服許多。Mercurial 毫不吝嗇地提供了這種方便－－而且沒有因此降低任何指令的可識別性。更別說您甚至可以在別人的機器上使用這些簡打指令，用簡打和他人溝通也沒問題。
 
**2.3. Mercurial 有防呆**
 
Mercurial 預設不允許使用者變更歷史紀錄。這意味著 Mercurial 的初學者，使用 Mercurial 時幾乎不可能失手摧毀自己或他人的倉庫。
 
（但如果您是進階使用者，想要取得更多的控制能力，只需要打開某些擴充套件就能這麼作。見後。）
 
初學者不用擔心摧毀版本庫，使本來就很好上手的 Mercurial 變得更友善。一旦我們能放膽去玩去嘗試它，自然也能更快熟悉這整套系統－－就算某個指令不懂，直接試用也不怕。反過來看，Git 某個指令不懂，直接試用看看通常表示妳要惹上大麻煩了。使用 Git 時，因為 reset 或 rebase 把東西玩壞的經驗，差不多每個人都會遇上個那麼幾次。
 
**2.4. Mercurial 便於共享**
 
與 Git 相比，Mercurial 的設計哲學使它更適合與他人協同工作，分享工作成果。
 
比方說 push 的預設處理範圍就不同……
 
   * Mercurial：預設推送本地所有提交。
   * Git：預設推送那些「有和遠端設定關聯 (track) 的本地分支中的提交」。
 
這意味著即使是 Mercurial 初學者，也能自然而然地使本地端與遠端資料正確同步，而不會因為分支未同步或沒有正確設定關聯，而搞出現些莫名其妙的蠢問題。
 
本地端的所有分支資料會很自然地備份到遠端，這讓使用者不容易因本地問題而遺失資料之餘，也方便和其他開發者共享開發狀況。
 
此外，Mercurial 分支避免引入命名空間的概念，故從根本上就減少了誤解；也沒有像 Git 那樣引入「遠端分支名稱可能與本地分支名稱不同」等不知何時才能派上用場的無謂複雜度，無需擔心推拉時打錯字等問題，這都是 Mercurial 比 Git 更便於共享的優點。（註四）
 
> 注意，push 的處理範圍只是預設。無論 Mercurial 與 Git，進階用戶都可以變更這些預設行為。
 
> 另外，雖然 Mercurial 預設讓用戶共享所有變更集，但如果用戶有進行某些本地實驗的需要，Mercurial 也可以簡單將某變更集（以及由他長出的後續變更集）設為不會被推送出去的「秘密開發路徑」，這些秘密的開發路徑不但不會被推送，也不會被其他人拉取或 clone 走，私下實驗時相當方便。這方面請參閱 Mercurial 的 Phases 概念。
 
 
####**Point3 - 關於 Mercurial 的常見誤解**####
 
以下是一些常常能在國內外討論中看到的，關於 Mercurial 的誤解。我將其整理了一下。
 
**3.1. Mercurial 並未缺少功能**
 
有人認為 Mercurial 相比 Git 的功能較少，對版本庫的控制能力較低，這是誤解。Mercurial 只是沒有將所有功能都整合進程式核心而已。
 
Mercurial 的設計邏輯，在於提供一個簡單強固的核心，與優秀的擴充介面。在 Mercurial 中，更多更強更危險的功能，以及某些正在開發的實驗性功能，都是由擴充套件來提供的。
 
請將官方發佈的擴充套件視為 Mercurial 的一部份，您就不會覺得 Mercurial 功能不足了－－不管是 rebase、strip、stage、合併多個變更集等等－－沒啥是 Git 能做而 Mercurial 做不到的。
 
比方說 Git 經常提及的 Stage 概念，在 Mercurial 中就是由 mq 擴充套件提供的。在 mq 的支持下，您不只像 Git 那樣可以暫存一個未完成的變更集，只要您想，您甚至可以暫存整串變更序列；更進一步地說，您不只可以 stage 一整串變更序列，您還可以分頭建立「好幾串」不同的序列，並行開發。再更進一步，如果您想，您甚至可以替您的暫存區做版本管理，甚至將暫存區版本庫推送到遠端……反過來說，如果您不需要 stage 的概念（我相信大部份的人都不需要），您也不會像 Git 那樣在提交時，三天兩頭因為忘記 stage (-a) 而得到「您啥也沒提交」的惱人訊息。
 
啟用擴充套件也非常輕鬆，畢竟**重要的擴充套件都是由官方製作並直接合併在 Release 中發佈的**。雖說名字叫作「擴充套件」，卻無需大費周章抓取安裝，取而代之，只要在設定檔中多加一行就能立刻啟用。
 
與 Mercurial 核心一併發佈的擴充套件，其品質都有著徹底的保證，其功能變更甚至會一併寫入 Mercurial 的 Release Changelog 中，強固性、相容性與被官方重視的程度，都是絲毫不遜於核心功能的。
 
**3.2. Mercurial 一點也不慢**
 
許多人認為 Mercurial 相比 Git 的問題在於它速度很慢，這是誤解。
 
雖然 Git 是用 C 寫的，Mercurial 是用 Python 寫的，看似會有速度差異，但事實上版本管理系統的速度瓶頸在於網路與 I/O，而 CPU 運算速度則影響不大。實際運用時我也從沒感覺 Mercurial 速度慢過 Git，更別說[許多世界上最大型的專案](http://en.wikipedia.org/wiki/Mercurial#Projects_using_Mercurial)都用他。 [Firefox](http://mozilla.com.tw/firefox/new/) 與 [Facebook](https://www.facebook.com/) 這些專案都是用 Mercurial 在管理他們的程式碼，我們的程式會比他們更龐大複雜嗎？
 
至少絕大多數狀況下，速度實在不是值得擔心的重點來著。
 
> 註：本節假設 Git 確實比 Mercurial 快，但事實上[在 Facebook 近期的幫助下](http://www.infoq.com/news/2014/01/facebook-scaling-hg)，如今的 Mercurial 在某些條件下甚至有 Git 的數倍快，雙方的速度差距正在縮小甚至逆轉。
 
> 另外還有一部份操作，原本就是 Mercurial 壓倒性的快。比方說在整個版本庫中搜尋特定字串時，hg grep --all “TEXT” 遠比 git grep “TEXT” $(git rev-list --all) 快，有時速度可差到 100 倍以上。（在一個約 1600 次提交，大小 300 M 的倉庫中，以上指令 Mercurial 需時 40 秒，Git 需時 45 分鐘）
 
**3.3. 進行危險操作時的安全性**
 
有人提到，Git 在進行如 rebase 這種破壞性操作時，其實是在版本庫中新增一個新的節點，並保留未來可用來回退這次破壞性操作的訊息；這些訊息會成為版本庫的一部份，因此用戶可以美妙地回退危險行為。
 
而另一方面， Mercurial 在處理破壞性操作時，只會自動匯出一個單獨的 bundle 檔案作為備份，而不是加在版本庫中，這使得回退很難被管理。
 
技術上來說，他們說得沒錯：Git 確實是把破壞性操作的復原訊息保留在版本庫的 reflog 中，而 Mercurial 則是將被刪除的資料匯出到版本庫之外。不過事實上，對那些東西進行操作的難度，卻完全顛倒了過來。
 
就從 Mercurial 開始吧。在 Mercurial 中，您要恢復一些被破壞性操作（如 rebase）毀滅的紀錄，只需要下這樣的指令：
 
    hg strip rebase_result_changeset # 先刪掉現有的 rebase 成果
    hg unbundle bundle.hg                # 將原本的分支取回來
 
就行了。
 
在實際取回分支前，您甚至可以先看看您究竟會匯入些什麼：
 
    hg incoming --graph bunble.hg        # 加上 --graph 後可用線圖顯示
 
另一方面，Git 要怎麼做？[這邊有一篇教學](http://blog.extracheese.org/2010/12/rebase-is-safe.html)可以參考……總而言之您需要施展一點 shell 魔法。
 
雖然原作者堅持這很簡單，事實上也確實不算太難（好吧，我是說對一個有能力編寫 shell 腳本的程式設計師而言，另外這個程式設計師還得對 Git 檔案系統與維護方式有著一定程度的理解，再者他還要有寫 unittest）……但是，和 Mercurial 的版本相比那又如何？
 
另外，基於容量與效率考量，Git 的復原紀錄會被 Git 不定時刪除（！）。至於 Mercurial 的復原記錄則只是一個普通的檔案，用戶想留就留，想扔就扔，想改名存到別的地方那就儘管去做，一切都看自己，不會有意外狀況發生。
 
Git 不會比 Mercurial 更安全。
 
 
 
###順便一提###
 
####**Point1 - Mercurial 的未來**####
 
Mercurial 的開發十分穩定有節奏。
 
它每月一號都會推出一個 bugfix 版本，每隔三個月會推出一個包含新特徵的版本，除了 hotfix 以外，兩年下來累計的誤差連十天都沒有。
 
除了穩定地修 bug、將操作介面改得更好用以外，它也持續在發展各種各樣新特徵。
 
* 【1.3 版】子版本庫：讓一個 Mercurial 倉庫中能納入其他倉庫。
* 【1.8 版】bookmark：讓 Mercurial 也能使用類似 Git 的臨時性分支。
* 【1.9 版】fileset：讓 Mercurial 用戶能輕鬆地指定檔案。   
 
            例→
            hg locate "set: binary() and modified() and not **.png"
            列出所有 png 以外，於目前工作目錄中被變更過的二進位檔案
 
* 【2.1 版】phase：使 rebase 這種重寫歷史紀錄的行為能夠被管理。
 
……當然還有更多！
 
我有提到 Mercurial 最近正在搞 [Bid Merge](http://mercurial.selenic.com/wiki/BidMerge) 嗎？這將讓 Mercurial 能自動處理極為複雜的合併問題。（已經實驗性引入 3.0 版中）
 
此外還有將「更動歷史」這件事也視為歷史之一部份－－讓 rebase 與 strip 事件能正確被 push pull 的 [Evolve 組件](http://mercurial.selenic.com/wiki/EvolveExtension)。本組件目前仍以擴充套件型式單獨存在，但幾乎所有 Mercurial 核心指令與外掛都在提供它所需要的資料了。這個專案持續發展了超過兩年，在本文撰寫的這個時間點，版本號已到達了 4.0.1 版，且依然在高速前進中。
 
Mercurial 的開發團隊也持續從 Git 最棒的特徵中汲取養份來改善自己。Bookmark 是如此， 用 XXX~1 這種優美語法來定位變更集相對位置也是。Mercurial 甚至還引入了 Git 的 diff 格式，只因為它真的更優秀。
 
總而言之，Mercurial 的進步鮮明，態度積極，其未來的發展與維護，是可靠而值得我們期待的。
 
####**Point2 - 您一定要試試 BitBucket**####
 
Mercurial 倉庫不能 Hosting 在 GitHub 上？沒有關係！我們有 [BitBucket](https://bitbucket.org/)！
 
BitBucket 可以幫用戶代管／發佈任意數量的 Mercurial 專案到網路上，無論是私密或開源專案都沒有問題，其網站介面與功能都有持續維護翻新，穩定度、流量、運行速度均有第一線水平。截至本文撰寫為止，最近一次大的介面改進發生在 2014 年 5 月底，在本來就很優秀的架構上，它正不停地變得更先進。Mercurial 用戶不好好利用實在是太可惜了。
 
對了，BitBucket 也能代管 Git 倉庫。就算您不喜歡 Mercurial 也大可試試。
 
####**Point3 - 好用的本地伺服器**####
 
Mercurial 內建零配置的網路伺服器，用戶只要在倉庫根目錄處打上：
 
    hg serve
 
就可以立刻把本地伺服器建立起來。
 
這個伺服器除了可供他人 push pull 以外，還能讓我們非常方便地透過瀏覽器查找各種資料。舉例如下：
 
![Alt text](Point3 - 好用的本地伺服器-某檔案的更動是由哪幾次提交造成的)
 
▴ 某檔案的更動是由哪幾次提交造成的
 
![Alt text](Point3 - 好用的本地伺服器-提交產生的樹狀圖，版本庫結構一目了然)
 
▴ 提交產生的樹狀圖，版本庫結構一目了然。
 
![Alt text](Point3 - 好用的本地伺服器-顯示誰修改了哪個檔案中的哪一行，追打他人時輕而易舉)  
 
▴ 顯示誰修改了哪個檔案中的哪一行，追打他人時輕而易舉。
 
![Alt text](Point3 - 好用的本地伺服器-水平比較檔案的兩個版本，比傳統的 diff 更容易讀)  
 
▴ 水平比較檔案的兩個版本，比傳統的 diff 更容易讀。
 
![Alt text](Point3 - 好用的本地伺服器-branch 列表，灰掉的是被關閉的分支)  
 
▴ branch 列表，灰掉的是被關閉的分支。
 
如此方便的工具不好好利用實在太可惜了。Mercurial 的本地伺服器還支援模版，內建甚至有和 git 網頁介面完全一樣的模版，如果您比較喜歡 Git 的網頁介面也可以選用。
 
####**Point4 - 圖形化工具 TortoiseHG**####
 
Mercurial 具有圖形化且完全開源的工具 TortoiseHG，在網路上一直有著不錯的評價。Mercurial 官網甚至將自身的更新日期與 TortoiseHG 的更新日期並列在一起，可見其地位。
 
不過我個人倒是沒有使用 TortoiseHG 的日常習慣，這方面就不便多做說明，就請有興趣的朋友自行試玩囉。
 
![Alt text](Point4 - 圖形化工具 TortoiseHG)  
 
▲TortoiseHG 的截圖，左側與上方標籤頁可同時追蹤好幾個倉庫，至於右側有著完善的線圖與提交資料。程式是用 PyQt4 寫的，相當具有現代感，而且全中文翻譯也需要讚一下。就算不用來提交更動，只用來檢視版本庫結構也不錯。
 
###附：延伸閱讀###
 
* [http://mercurial.selenic.com/wiki/GitConcepts](http://mercurial.selenic.com/wiki/GitConcepts)    
Git 用戶轉移到 Mercurial 時可參考的觀念與指令對應文件
* [http://steveko.wordpress.com/2012/02/24/10-things-i-hate-about-git/](http://steveko.wordpress.com/2012/02/24/10-things-i-hate-about-git/)
這是一篇對 Git 的深入抱怨，其中提到 Git 「沒有抽象性」以及「打破承諾」的問題特別值得我們注意，相當有看點。不過這篇文章和 Mercurial 沒有直接關係。
 
###註解###
 
前面的話題中有部份瑣碎的細節不好講，故補充在此。各位可斟酌跳過。
 
####**註一：想保留 Git 的分支路線訊息？**####
 
如果您願意加上一堆但書，Git 也不是完全做不到，前題是您得紮實地用 --no-ff 與 rebase 小心整理線圖、保留 Git 分支不把它刪除、並想辦法計算 merge 與 branch 的分岔點合併點……又或是固定在提交紀錄中寫入當時的分支名稱，而且透過人工保證這名稱不會和其他用過的名稱重複。而且－－這是最難的－－您還得確保您的所有協作伙伴都有確實這麼做。
 
但無論如何，這是人的苦勞，而不是工具的功勞。要說 Git 能辦到這個實在相當勉強。
 
另外補充一下，git 的 reflog 也可以在某種程度上保留分支資訊，不過有以下問題：
 
1. reflog 是本地的。無法被 clone 走，也無法被推到遠端。
2. 當分支內容有部份是被 pull 下來時，本地的 reflog 會跳過這些提交。
3. 老舊的 reflog 會被自動回收掉（此為預設值，但可以修改這個行為）
4. reflog 畢竟是 refs 的移動紀錄，而不是提交紀錄。如果您曾手動移動過 Git 分支標籤，reflog 顯示的資訊就不再是依序排列的了，而且還會有各種交叉、重複、跳過……
 
總之，Git 就是沒有一個簡單的方法讓人找回「約 250 次提交前，為了開發 X 功能而在某分支中進行的 N 個提交」。Git 用戶只能靠自己的腦子與嚴謹的紀律－－而非工具－－來處理這些問題。
 
####**註二：Git 用戶怎麼解決隱藏分支的問題？**####
 
* 有些 Git 用戶[將分支轉成 Tag](http://www.aaronwest.net/blog/index.cfm/2011/6/7/Git-Workflows-Archiving-Old-Branches)，藉此封存想要保留的舊分支。
* 另外還有 Git 用戶建議[使用 update-ref 將分支的 ref rename 到 heads 以外的地方](http://git.661346.n2.nabble.com/how-to-hide-some-branches-td1594799.html)。
 
然而上述兩種方法大量依賴人工，光看就讓人想哭了，實際上難以正式投入使用。
 
最值得推荐的作法或許是利用指令……
 
    git branch --no-merged
 
……藉此來列出所有「未合併進當前分支的分支」，換句話說，已被合併到工作目錄的分支就不會顯示出來。
 
不過這個意義與「封存特定分支」其實有差，只能在特定的開發方式或較小的協作規模中才能被有效使用。實際上依然無法達成封存分支的效果。
 
####**註三：如何有效運用含有多個 heads 的分支？**####
 
「Branch 中能有多個 Head」這是 Mercurial 中一項相當有彈性的特徵，然而隨便將它推送到遠端反而可能搞混您的開發伙伴。Mercurial 用戶通常會用以下方法控制 heads：
 
**不推送匿名 head 到遠端**
 
Mercurial 允許同一個 branch 中有很多 Head，但他不希望您將一堆匿名 head 推送給他人共享（本地使用則無所謂），因為這會讓您的合作伙伴在 pull 後感到困惑：
 
> 「奇怪，原本的 branch 怎麼突然多出了 N 個頭（而且都沒特殊標記），我現在要用哪個頭進行開發？」
 
－－像是如此這般。
 
對此 Mercurial 的建議是：如果您在嘗試 push 時得到了「這麼做 head 會增加」的警告，先不要勉強下 --force 硬推，取而代之，在絕大多數情況下，您應該先將遠端現有的變更拉下來看看多了什麼，然後在本地和您現有的變更合併（或 rebase），完成後再 push 到中央倉庫去，這可確保頭部數目不會增加。
 
當然，有時您推送的目的就是想要增加一個額外的頭部，那麼您可以在這些頭部加上 bookmark 後，再用 --force 進行推送，以利用戶識別。
 
**察看當前分支中的 head 們**
 
使用如下指令：
 
    hg heads .
 
這可以讓您列出當前的 branch 中的所有頭部（預設不含已經被關閉的頭部），然後您就能一目了然地，任意在他們之間切來換去了。
 
**關閉無用的頭部**
 
您可以用 hg commit --close-branch 來關閉那些無用的頭部，而不需要將其合併到任何地方。這可以用來處理一些您不想繼續使用的變更路徑。
 
被關閉的頭部預設不會被列入 hg update BRANCH_NAME 的切換候選之中，所以除非刻意指定那個變更集，否則 update 時不會切到它頭上去。
 
####**註四：為什麼 Mercurial 不需要引入分支命名空間？**####
 
Mercurial 的 Branch 沒有命名空間的概念，所有 Branch 名稱都共用同一個命名空間－－這點常常被 Git 用戶指出，並視為缺點。
 
不過真相是：Mercurial branch 與 Git branch 的實現邏輯並不相同－－Mercurial Branch 是標記一群變更集，而 Git Branch 則是標記頭部－－故 Mercurial 的 branch 不會因為名稱相同而無法工作，也因此不需要有命名空間的概念。
 
Mercurial 的 branch 名稱總是唯一，且相同名字的 branch 總是會指向「同一群」提交－－這不允許混淆也不會混淆。（但在 branch 擁有多個頭部的情況下，如果用 branch 來指定頭部，不見得會指向同一個頭部，請參考註三）
 
另一方面，與 Git branch 運作邏輯相似的 Mercurial bookmark，則與 Git 同樣有著「遠端與本地 bookmark 同名，但其實是指不同變更集」的問題存在。
 
然而，與其像 Git 那樣引入命名空間的概念，Mercurial Bookmark 寧願選擇「儘可能讓遠端與本地的 bookmark 在推拉時自然同步」這種策略－－Mercurial 會自動讓同名 bookmark 在推拉時依照開發樹的方向自然同步推進。唯有因為路徑分岔而無法自然同步時，才會臨時產生一個命名空間，如「bookmark@default」這樣以資區別。
 
這同樣也是利於共享的設計。
 
###尾聲###
 
這篇文章，到此也算告一段落了。在本文中，我描述了大量我注意到的，關於 Mercurial 與 Git 相比較時的優點。
 
然而，我也完全明白，您可能根本不在乎我所說的那些優點。
 
比方說，您可能根本不在乎能否保留分支、對輕鬆檢索變更集的能力嗤之以鼻、覺得簡單易學的命令行操作算不上什麼好處。您可能不認為自己需要一個零設定就能運行的網頁伺服器、覺得嚴肅對待版本與分支歷史的設計理念沒啥用處、不在乎版本管理器需不需要一個易寫易用的插件系統、對更多可能的分支模型聳聳肩、覺得用 shell script 來復原 rebase 只是小事一樁……
 
沒問題的，您當然可以有您自己的選擇。就像我一開始所說的那樣，我只是出來辟謠的。
___


##[源碼秘技] 如何搶救 Linux 上不能開機的 GRUB 2##


謝良奇／翻譯


**本文翻譯自 Linux.com，原作者為 Carla Schroder：[http://www.linux.com/learn/tutorials/776643-how-to-rescue-a-non-booting-grub-2-on-linux/](http://www.linux.com/learn/tutorials/776643-how-to-rescue-a-non-booting-grub-2-on-linux/)**


從前我們使用過的舊版 GRUB，也就是 Grand Unified Linux Bootloader 0.97 版，雖然有許多優點，但隨著它變得過時且開發者也渴望更多功能，於是我們才有了 GRUB 2。


重大改寫的 GRUB 2 在許多方面有著顯著差異。例如允許從可移除式媒體開機，以及透過選項設定進入系統 BIOS。一改將所有設定寫在一個簡單的 /boot/grub/menu.lst 檔案中，它利用各種腳本程式進行設定的方式更為複雜，預設腳本為 /boot/grub/grub.cfg。不過你不會直接編輯這個腳本，這個腳本程式不是讓人而是讓其他腳本來修改的。我們這些卑微的用戶只能編輯主要用來控制 GRUB 選單外觀的 /etc/default/grub。我們還可以編輯 /etc/grub.d/ 底下的腳本。正是這些腳本將你的作業系統開機，控制外部應用程式像是  memtest 與 os_prober，接著再進行主題設定。當你執行 update-grub 指令時，/boot/grub/grub.cfg 會從 /etc/default/grub 以及 /etc/grub.d/* 建構出來，因此每當你修改後都要再次執行。


好消息是 update-grub 腳本能夠找出核心、開機檔案，並將所有作業系統加入你的 GRUB 開機選單中，所以你不再需要手動執行。


我們將學習如何修復常見的兩大錯誤。當你開機後系統停在 grub> 提示符，那是 GRUB 2 的命令 shell。這意味著 GRUB 2 雖然正常啟動並載入了 normal.mod 模組 (以及放在 /boot/grub/[arch]/ 底下的其他模組)，卻找不到你的 grub.cfg 檔案。如果你看到的是 grub rescue>，這表示它找不到 normal.mod，因此可能也找不到你所有的開機檔案。


怎麼會這樣？核心也許更改了磁碟配置，或者你移動了你的硬碟，你改過分割區，或者安裝了新的作業系統並且搬動了許多檔案。在這些情況下，雖然你的開機檔案還在，GRUB 卻找不到。因此你可以在 GRUB 提示符上尋找你的開機檔案，設定其位置，然後開機並修復你的 GRUB 設定。


###GRUB 2 命令 Shell


GRUB 2 命令 shell 就和舊版 GRUB 的 shell 一樣強大。你可以用它來找開機映像、核心、root 檔案系統。事實上，它允許你在本地機器上擁有所有檔案系統的存取權，而不需理會權限或其他保護措施。雖然有些人可能視此為安全漏洞，但就像一句老 Unix 格言所說的，誰擁有實體存取就等於擁有機器。


當你在 grub> 提示符下，你可以使用許多類似其他命令 shell 的功能，像是歷史命令與 tab 鍵的自動完成。grub rescue> 限制較多，不提供上述兩項功能。


當你在可運作系統上做實驗時，當你的 GRUB 開機選單出現時按下 C 鍵以開啓 GRUB 命令 shell。你可以利用方向鍵在選單項目上捲動以停止開機倒數。在 GRUB 指令列上做些實驗是很安全的，因為你所做的更動都不是永久性的。如果你已經看到 grub> 或 grub rescue>，表示你已經準備好了。


下列幾個指令可以用在 grub> 與 grub rescue> 上。你應該執行的第一個指令是啟動分頁，為的是分頁顯示過長的指令輸出：


    grub> set pager=1


在等號兩邊不能有空格。現在讓我們做點小小探索。輸入 ls 來列出 GRUB 能看到的所有分割區：


    grub> ls
    (hd0) (hd0,msdos2) (hd0,msdos1)


這些 msdos 代表什麼？這表示這個系統有舊的 MS-DOS 分割表，而不是新的 Globally Unique Identifiers 分割表 (GPT)。如果你用的是 GPT，它會顯示 (hd0,gpt1)。現在讓我們多探查一番。使用 ls 指令來看你系統上有哪些檔案：


    grub> ls (hd0,1)/
    lost+found/ bin/ boot/ cdrom/ dev/ etc/ home/  lib/
    lib64/ media/ mnt/ opt/ proc/ root/ run/ sbin/
    srv/ sys/ tmp/ usr/ var/ vmlinuz vmlinuz.old
    initrd.img initrd.img.old


好哇，我們找到 root 檔案系統了。你可以省略 msdos 與 gpt 的標籤。如果你省略斜線，則會顯示分割區的資訊。你可以用 cat 指令讀取系統上的任何檔案：


    grub> cat (hd0,1)/etc/issue
    Ubuntu 14.04 LTS \n \l


讀取 /etc/issue 能幫助在多重開機系統上辨識你的各個 Linux。




###從 grub> 開機


以下是如何從 grub> 提示符上設定開機檔案並開啓系統。我們從 ls 指令執行得知 (hd0,1) 上有個 Linux 的 root 檔案系統，你可以繼續搜尋直到你確認 /boot/grub 在哪裡。接著執行以下指令，以使用你的 root 分割區、核心、initrd 映像：


    grub> set root=(hd0,1)
    grub> linux /boot/vmlinuz-3.13.0-29-generic root=/dev/sda1
    grub> initrd /boot/initrd.img-3.13.0-29-generic
    grub> boot


第一行設定 root 檔案系統所在的分割區。第二行告訴 GRUB 你想要使用的核心。只要輸入 /boot/vmli 並使用 tab 鍵自動完成填滿路徑。輸入 root=/dev/sdX 來設定 root 檔案系統的位置。沒錯，這看起來有些多餘，不過如果你沒指定，你會得到核心 panic 錯誤。如何得知正確的分割區？hd0,1 = /dev/sda1、hd1,1 = /dev/sdb1、hd3,2 = /dev/sdd2。剩下的你應該能類推出來。


第三行是設定 initrd 檔案，跟核心必須是同樣的版本號。


第四行是進行開機。


在某些 Linux 系統上，目前的核心與 initrd 會被符號連接到 root 檔案系統的最上層：


    $ ls -l /
    vmlinuz -> boot/vmlinuz-3.13.0-29-generic
    initrd.img -> boot/initrd.img-3.13.0-29-generic


因此你可以在 grub> 這樣開機：


    grub> set root=(hd0,1)
    grub> linux /vmlinuz root=/dev/sda1
    grub> initrd /initrd.img
    grub> boot


###從 grub-rescue> 開機


如果你是在 GRUB 救援 shell，指令會有所不同，而且你必須載入 normal.mod 和 linux.mod 模組：


    grub rescue> set prefix=(hd0,1)/boot/grub
    grub rescue> set root=(hd0,1)
    grub rescue> insmod normal
    grub rescue> normal
    grub rescue> insmod linux
    grub rescue> linux /boot/vmlinuz-3.13.0-29-generic root=/dev/sda1
    grub rescue> initrd /boot/initrd.img-3.13.0-29-generic
    grub rescue> boot


當你載入這些模組後，應該就能使用 tab 鍵自動完成了。


###讓修復永久生效


當你成功開機後，執行下列指令以永久性修復 GRUB：


    # update-grub
    Generating grub configuration file ...
    Found background: /usr/share/images/grub/Apollo_17_The_Last_Moon_Shot_Edit1.tga
    Found background image: /usr/share/images/grub/Apollo_17_The_Last_Moon_Shot_Edit1.tga
    Found linux image: /boot/vmlinuz-3.13.0-29-generic
    Found initrd image: /boot/initrd.img-3.13.0-29-generic
    Found linux image: /boot/vmlinuz-3.13.0-27-generic
    Found initrd image: /boot/initrd.img-3.13.0-27-generic
    Found linux image: /boot/vmlinuz-3.13.0-24-generic
    Found initrd image: /boot/initrd.img-3.13.0-24-generic
    Found memtest86+ image: /boot/memtest86+.elf
    Found memtest86+ image: /boot/memtest86+.bin
    done
    # grub-install /dev/sda
    Installing for i386-pc platform.
    Installation finished. No error reported.


當你執行 grub-install 時，記得你正在把開機磁區安裝到你的硬碟上，而不是分割區。所以不要用 /dev/sda1 這樣的分割區號碼。


如果這樣做都不能修復你亂七八糟的系統，試試看 [超級 GRUB2 live 救援磁碟](http://www.supergrubdisk.org/)。官方 [GNU GRUB 手冊 2.0](https://www.gnu.org/software/grub/manual/grub.html) 應該也會有幫助。
___


##[源碼新聞] MakerConf ─自造者年會，捲起袖子動手玩！##


四貓╱文

Maker 運動在做些什麼？ Maker 文化、和 Maker 精神怎麼體現？成為一個 Maker 可以在哪裡取得資源和找到志同道合的社群夥伴？ 這些，MakerConf 一次帶給你！自造文化的風潮從國外吹進台灣，我們可以看到群眾集資網站上許多創新產品不斷誕生， 也可以發現 3D 印表機和四軸飛行器的普及吸引了許多人投入自造之路，但 Maker 還有更多的可能等你來發掘！透過做中學 (learning-through-doing) 的行動，發揮無限的創意。在 MakerConf，你可以和對自造有興趣的夥伴們一起體驗創造的樂趣。  

- 舉辦日期：2014 年 8 月 9 日  
- 舉辦地點：中央研究院 人文社會科學館
- 會議主題：  
        - Maker 主題介紹：Maker 精神、Maker 文化與 Maker 資源介紹。  
        - 人機介面 (HCI/HMI)：使用開源軟硬體在人機介面上的改進與展示。  
        - 理論與工程的結合：使用開源軟硬體所實作的專案，並能深入說明所使用的理論與工程意義。  
        - 教學與教育的應用：使用開源軟硬體在教育或教學上的應用與展示。   
- 詳細講者及議程請見：[http://www.makerconf.tw/](http://www.makerconf.tw/)
- 報名頁面：[http://makerconf.kktix.cc/events/2014-regist](http://makerconf.kktix.cc/events/2014-regist
)
___


##[源碼新聞] DrupalCamp Taipei 2014 活動訊息##
 
Drupal Taiwan╱文
 
今年的 DrupalCamp Taipei 2014 主題為「Drupal X 跨界整合」將會在 8/29（五）- 8/30（六）於犇亞國際會議中心及國立政治大學舉辦，活動首日隆重聚獻-「企業日」廣邀企業人士，透過 Drupal 國際大師級講師現身說法，以及 Drupal Taiwan 業界各領域社群交流，精彩呈現 Drupal 於各產業界實際運用整合的案例；活動次日-「社群日」，無論您來自何方，請帶著您對 Drupal 的熱情，我們誠摯歡迎您一同來參予這屬於 Drupal 的夏之饗宴。
 
首日特別打造專屬於企業或團體用戶的「企業日」，活動當日邀請開發者排名 TOP 30 的 JohnAlbin 為我們談談 Drupal 的最新發展的走向與趨勢。並邀請 CACOO 日本工程師來談 CACOO 如何運用 Drupal 打造方便易用的**知識管理系統**，並分享如何克服網站效能瓶頸的寶貴經驗。**Nownews 的資深工程師 Richard Fu 也將分享 Nownews 如何利用 Drupal 打造每日數十萬點月次數的新聞網站**。友達資深工程師 Yelban 將談談用 Drupal**批次建造與管理大量的公司內部網站有多方便**。
 
而在社群日這一天，延續往年 Drupal Taiwan 致力於推廣 Drupal 的目標，在這個 Druapl 已於全台各地遍地開花的現況下，於各產業界皆可見 Drupal 運用的例子，Drupal 跨足於網路旅遊產業、交通管理產業、廣告製作產業、文創產業等。針對 Drupal 運用於各產業之間，Drupal 帶來了更好的使用經驗以及實務管理的大幅提升，我們期待藉由活動的推廣及探究，更深入探討 Drupal 導入各界的無限可能。
 
詳細議程內容請參考網址：[http://2014.drupalcamp.tw/session-schedule](http://2014.drupalcamp.tw/session-schedule)
 
早鳥票也同時開賣，數量有限，到 8/1 為止。售票相關請參考：[http://2014.drupalcamp.tw/tickets](http://2014.drupalcamp.tw/tickets)
___


##[源碼新聞] 2014 年八月份社群活動列表##


OSSF 電子報團隊／整理


八月份的活動謝表出爐囉！有興趣的朋友們請多多邀請您的朋友們一同前往參與！另外，由於活動列表出來的時間比較早，若後續有活動希望也能一起做宣傳的朋友們，請記得來信告訴我們喔！信箱： ossfepaper@openfoundry.org 。


###Taipei Wikipedian Weekly Meetup: Community Operation 維基台北定期聚—社群經營工作雙週聚（每週五，8/1、8/8、8/15、8/22、8/29）###


- 時間：19:00~21:00
- 地點：台北市中山區德惠街 23 號地下一樓（摩茲工寮 | Mozilla Community Space Taipei）
- 活動資訊：[http://zh.wikipedia.org/zh-tw/WP:WPTP-S](http://zh.wikipedia.org/zh-tw/WP:WPTP-S)


###MozTW Lab @ TP（每週五，8/1、8/8、8/15、8/22、8/29）###


- 時間：19:00~22:00
- 地點：台北市中山區德惠街 23 號地下一樓（摩茲工寮 | Mozilla Community Space Taipei）
- 活動資訊：[https://groups.google.com/group/moztw-general](https://groups.google.com/group/moztw-general)


###SA@Tainan 『來自星星的ERP』（8/2）###


- 時間：14:00~17:00
- 地點：台南市東區大學路 1 號（國立成功大學成功校區資訊館 65203 教室）
- 活動資訊：http://samc.study-area.org/registry/add/154


###Hack Generation（8/2~8/3）###
- 地點：大同大學尚志大樓
- 活動資訊：http://hackgen.sitcon.org/


###TOSSUG BoF（每週二，8/5、8/12、8/19、8/26）###


- 時間：18:00~22:30
- 地點：台北市中正區羅斯福路三段 284 巷 5 號 2 樓（Ville Cafe）
- 活動資訊：[http://www.tossug.org/](http://www.tossug.org/)


###MozTW Lab @ 基隆（每週三，8/6、8/13、8/20、8/27）


- 時間：19:00~21:00
- 地點：基隆市仁愛區港西街 4 號 1 樓（1915 海洋咖啡館）
- 社群網址：[https://groups.google.com/group/moztw-general](https://groups.google.com/group/moztw-general)


###Hacking Thursday（每週四，8/7、8/14、8/21、8/28）###


- 時間：19:30~22:30
- 地點：台北市大安區建國南路一段 166 號 2 樓 (伯朗咖啡館建國店)
- 活動資訊：[http://www.hackingthursday.org/](http://www.hackingthursday.org/)


###KSDG 高雄開發者社群 (Kaohsiung Software Developer Group) meetup（8/7）###


- 時間：19:00~21:00
- 地點：高雄軟體園區 B 棟 708 室（高雄市前鎮區復興四路 2 號 7 樓之 5）
- 社群網址：[https://www.facebook.com/groups/KSDGroup](https://www.facebook.com/groups/KSDGroup)


###MakerConf（8/9）###
- 地點：台北市南港區研究院路二段128號（中央研究院 人文社會科學館）
- 活動資訊：http://www.makerconf.tw/


###SA@Tainan ERP 的導入與後續經營 - 談聯想與金蝶的個人經驗：資訊部門管理的標準化（8/9）###


- 時間：13:30~17:00
- 地點：台南市東區大學路 1 號（國立成功大學成功校區資訊館 65203 教室）
- 活動資訊：http://samc.study-area.org/registry/add/155


###Taipei Wikipedia Moonthly Meetup: Writing Day 維基台北定期聚—假日寫作月聚（8/9）###


- 時間：14:00~16:00
- 地點：台北市松山區南京東路二段一號（伯朗咖啡 南京二店二樓）
- 活動資訊：[http://zhwp.org/zh-tw/WP:WPTP-W](http://zhwp.org/zh-tw/WP:WPTP-W)


###玉里維基寫作（8/9）###


- 時間：19:30~21:00
- 地點：台灣花蓮縣玉里鎮民權街 58 巷 6 號（酸柑咖啡）
- 活動資訊：[https://www.facebook.com/events/258313251013823/](https://www.facebook.com/events/258313251013823/)


###Cocoaheads Kaohsiung（8/14）###


- 時間：19:00~21:00
- 地點：高雄市前鎮區復興四路 2 號 7 樓之 5，708會議室
- 活動資訊：https://www.facebook.com/groups/cocoaheads.kaohsiung


###KSDG web course（8/16）###


- 地點：高雄市前鎮區復興四路 2 號 7 樓之 5，708 會議室
- 社群網址：[https://www.facebook.com/groups/KSDGroup](https://www.facebook.com/groups/KSDGroup)


###CTLUG (Central Taiwan Linux User Group) meetup（8/16）###


- 時間:14:00~16:30
- 地點:台中市北區錦新街 42 號 2 樓（HexBase）
- 活動資訊：[https://ctlug.hackpad.com/](https://ctlug.hackpad.com/)


###維基漫步 - 南港場（8/16）###
- 地點：台北市南港區研究院路二段128號（中央研究院資訊所）
- 活動資訊：https://kktix.com/events/wikimambo1408/registrations/new


###WoFOSS 2014 / 8 月第 48 次聚會（8/21）###
- 時間：19:00~22:00
- 地點：台北市松山區民生東路三段 140 巷 11 號（果子咖啡）
- 活動資訊：http://wofoss.kktix.cc/events/wofoss048-201408


###SA@Ksohsiung 從基礎紮馬了解佈線（8/23）###
- 時間：13:30~17:30
- 地點：高雄市前鎮區復興四路 2 號 7 樓 708 室 (地圖)
- 活動資訊：http://samc.study-area.org/registry/add/156


###DrupalCamp Taipei 2014（8/29~8/30）###
- 地點：8/29 台北市松山區復興北路 99 號 6 樓（犇亞會議中心），8/30 臺北市文山區指南路二段 64 號（國立政治大學）
- 活動資訊：http://2014.drupalcamp.tw/


###RailsGirls Taipei #4（8/29~8/30）###
- 地點：台北市松山區復興北路 99 號 15 樓（犇亞會議中心）
- 活動資訊：http://railsgirls.kktix.cc/events/rg-taipei-4
___




#關於本報#
 
 
◎ 主編︰洪華超
 
◎ 法律專欄編輯︰葛冬梅
 
◎ 執行編輯︰洪立穎、劉佩昀
 
◎ 外稿編譯︰林誠夏、黃郁文、謝良奇
 
本電子報自行採訪、報導、編譯、撰寫文章之智慧財產權屬於中央研究院，採用創用CC「姓名標示－禁止改作－非商業性」授權條款臺灣 3.0 版授權散布，歡迎在不變更內容的前提下，以任何形式重製與散布本報，但必須遵守下列義務︰(1) 不得為商業目的之利用；(2) 必須標明本電子報智慧財產權屬於中央研究院；(3) 完整引用本著作權說明。
 
若欲以創用CC「姓名標示－禁止改作－非商業性」授權條款臺灣 3.0 版以外的方式利用上述文章，請與自由軟體鑄造場編輯群(ossfepaper at openfoundry.org) 聯絡。
 
非自由軟體鑄造場自行撰寫的單篇文章，其智慧財產權利屬於原作者所有，其以非專屬的方式授權予自由軟體鑄造場運用，而與本電子報其他文章併以創用 CC「姓名標示－禁止改作－非商業性」授權條款臺灣 3.0 版的方式進行散布。
 
若欲以創用CC「姓名標示－禁止改作－非商業性」授權條款臺灣 3.0 版以外的方式利用個別作者的文章，請自行與該作者聯繫，或透過自由軟體鑄造場編輯群 (ossfepaper at openfoundry.org) 來轉發聯絡訊息。
 
授權條款全文請見︰
[http://creativecommons.org/licenses/by-sa/3.0/tw/legalcode](http://creativecommons.org/licenses/by-sa/3.0/tw/legalcode)
 
授權條款簡介請見︰
[http://creativecommons.org/licenses/by-sa/3.0/tw/deed.zh_TW](http://creativecommons.org/licenses/by-sa/3.0/tw/deed.zh_TW)
 
若欲訂閱本電子報，請至以下網址︰
[http://www.openfoundry.org/tw/news](http://www.openfoundry.org/tw/news)
 
如欲取消訂閱這份電子報，可透過自由軟體鑄造場新聞首頁左上方之自動退訂機制︰
[http://www.openfoundry.org/tw/news](http://www.openfoundry.org/tw/news)
 
或寄發電子郵件至︰ossfepaper@openfoundry.org，以進行人工退訂。