________________________________________________________________

□■□ 自由軟體鑄造場電子報第 214 期 | 2013/03/12 □■□
________________________________________________________________

◎ 本期主題︰MyPaint 1.1 新鮮事－老玩具，新東西
◎ 訂閱網址︰http://www.openfoundry.org/tw/news/
◎ 下次發報時間︰2013/03/26

□ 本期標題 □__________________________________________________

﻿■ [源碼秘技] MyPaint 1.1 新鮮事－老玩具，新東西

﻿■ [源碼秘技] 《雪凡與好朋友們的 Ren'Py 遊戲引擎初學心得提示》第七回：粒子之下，色彩之上

﻿■ [自由專欄] 開發者訪談：DOS 已死，FreeDOS 永存

﻿■ [自由專欄] 網站技術發展史

■ [源碼新聞] iOS 與 Android 的開放源碼 JavaFX 即將到來

■ [源碼新聞] Raspberry Pi Model A 在歐洲開賣並規劃跨向全球

■ [源碼新聞] Valve 釋出 Steam for Linux

■ [源碼新聞] Document Foundation 發表 LibreOffice 4.0

■ [源碼新聞] Microsoft 發布德國慕尼黑市 Linux 轉換計畫調查報告與官方分析有明顯落差

■ [源碼新聞] Drupal Taiwan 3 月的各地聚會資訊，歡迎踴躍參加！
______________________________________________________________


□ 本期內容 □__________________________________________________

﻿■ [源碼秘技] MyPaint 1.1 新鮮事－老玩具，新東西

林雪凡／文

軟體名稱：MyPaint
介紹版本：1.1
官網：http://mypaint.info
授權：GPL-2.0+
 

簡介

MyPaint 是一款搭配繪圖板使用的，專門供藝術家進行手繪的軟體。它擅長模擬各種現實世界中的畫筆效果。細節見之前的介紹文章。

自從 2011 年底推出 1.0 穩定版後，MyPaint 專案看似沉寂了好長一段時間，然而在背後，各式各樣的修復與新功能依然不斷被推入源碼庫中。終於在 2013 年一月初，MyPaint 1.1 版本正式推出。

本篇文章只是作者個人把玩的理解與摘要，官方原始介紹文見此：

http://www.davidrevoy.com/article154/mypaint-1-1-a-guide-through-the-new-features 

 

新東西
 

【對稱模式】

可以在畫面上產生一條臨時的虛線。在這條虛線左側畫圖時，右側對應位置會自動產生相應的線，反之亦然，如同鏡射一般。畫對稱物體時手感很棒！

不過另一方面，本功能目前還不夠成熟，關鍵的「對稱軸位置」無法被程式記憶下來。一旦關閉對稱模式再開啟，對稱軸只會出現在當前視埠的正中央，開關之間對稱軸容易跑位，因此暫時只能用來畫點小東西。 

 

【新的「畫線」繪圖模式】

為了提高尺規作圖能力，新版的 MyPaint 將繪圖模式一分為四：「隨手畫 (P)」、「線條 (K)」、「連續線 (J)」、「橢圓 (O)」。

「隨手畫」是最原始的模式。而「線條」與「連續線」模式可以用拖曳的方式畫出直線，隨後搭配 Shift 鍵可將直線拉成柔和的弦線。「橢圓」顧名思義就是用來畫橢圓用的。

新增加的三種模式可用來畫精確的線，以解決繪圖板上不能用尺的問題，而且這種線還可以保持先前手畫時的筆刷效果、做出筆壓變化、並被輕易撓曲成各種曲線。用起來異常順手，手感極佳。

三種模式都能搭配 Shift 與 Ctrl 等按鈕使用，具體按鍵鍵位請自行試試或翻查原始發佈公告。

 

【色票與檢色器】

1.0 沒有色票功能，想用色票還得自己開個小圖來手工製作。現在可好了，1.1 版徹底解決了色票問題。除了預設提供的色票外，畫家還可以用檢色器旁邊的書籤按鈕將當前顏色錄入色票集之中，自行擴充色票集。

在檢色器方面，1.1 版額外提供了 HSV 與 HCY 的檢色介面。

 

【色域遮罩】

您可以在 HCY 檢色器上加入「色域遮罩」（請點選選色視窗角落處的設定按鈕）。這功能可幫畫家限制住用色的範圍，進而相對輕鬆地畫出具有特定色彩氛圍的圖片。

順便一提，MyPaint 開發者聲稱這是世界上第一款支援色域遮罩功能的繪圖軟體。

 

【更多的圖層混色模式】

1.0 時只有 4 種圖層混色模式，可憐到不行，如今暴增到 16 種，實用性大大增加了。

與混色模式相關，MyPaint 還新提供了一項功能：「在畫面顯示效果相同的前提下，將圖層混色模式轉為普通模式」。這功能被放在圖層選單中，請自行找找。

 

【畫框 (Frame) 強化】

MyPaint 的一大特色就是擁有無限大小的圖層，讓畫家在畫圖時不用費心管理圖層大小。然而反過來說，搞不清楚圖片有多大，圖片的邊界在哪裡，這也同時會給畫面佈局與匯出圖片帶來一些問題。

畫框功能可提供一個很容易調整、變更的虛擬範圍，讓圖片在匯出時自動略去範圍外的東西。畫家可隨時調整畫框的位置與大小，不需要時也可以輕鬆關掉。另外，畫框只影響匯出，不影響作畫－－如果在畫框外塗鴉一樣會畫上去的。

其實早在 1.0 時 MyPaint 就有畫框功能了（可從設定頁面開啟），不過當時還很不好用，明顯有 bug 而且手感也不對。現在看來已被充份完善過，可派上用場了。

 

【新的筆刷混色模式】

繼之前的「普通 (N)」、「橡皮擦 (E)」、「鎖定 Alpha (Shift + L)」之後，新的筆刷混色模式是「上色 (Shift + K)」。效果乍看之下有點像「鎖定 Alpha」，但除了 Alpha 外也鎖定了明度。

 

【其他的改變】

加入了圖層平移功能（終於！）。對於不善一次到位完成構圖的人來說，調整構圖變方便了不少。不過旋轉縮放等依然沒有，不要指望這個，請匯出後自行處理。
更廣義的熱鍵自定義功能。有些原本不能定義的熱鍵，如畫圖時按住的 Shift 輔助鍵等，現在可在偏好設定視窗中進行定義了。
筆刷設定視窗也強化了。
 

MyPaint 1.1 保持了其一貫的精簡，新加入的功能幾乎全都非常實用而且順手。推荐各位儘早升級試用看看！
_______________________________________________________________

■ [源碼秘技] 《雪凡與好朋友們的 Ren'Py 遊戲引擎初學心得提示》第七回：粒子之下，色彩之上

林雪凡／文

又到了眾所期待的 Ren'Py 節目時間。大家好，我是節目主持人雪凡。
(http://www.openfoundry.org/images/130226/renpy7/Head_Secure_1_1.jpg)「我是絲蔻兒。」

(http://www.openfoundry.org/images/130226/renpy7/Head_Info_1_3.jpg)「我是音符呀。」

啊哈，兩位熟悉的搭檔再次登場，在下可是無任歡迎的呢。

不過，本回的內容......也算是上回的擴展與補充。程式碼可是有相當份量的說。看到程式碼就該咚咚登場的泰克斯 (text)，人又到哪去了？

(http://www.openfoundry.org/images/130226/renpy7/Head_Secure_1_3.jpg)「那傢伙狀況挺糟的，壓根就沒出門啊。」

(http://www.openfoundry.org/images/130226/renpy7/Head_Info_1_2.jpg)「呀......那、那個......小泰他，好像是在煩惱些什麼......我們有點不好叫他......」

哈啊？

(http://www.openfoundry.org/images/130226/renpy7/Head_Secure_1_3.jpg)「嘛啊～也不知怎麼搞的...... 自從上次上完節目，就看他一臉失魂落魄的樣子，嘴裏總在喃喃自語：『我絕對不可能和絲蔻兒越來越像』什麼的......完全不知道在想什麼呢！」

(http://www.openfoundry.org/images/130226/renpy7/arrow.jpg) (http://www.openfoundry.org/images/130226/renpy7/Head_Text_1_16.jpg)「我不可能和絲蔻兒越來越像，我不可能和絲蔻兒越來越像......」

(http://www.openfoundry.org/images/130226/renpy7/Head_Info_1_8.jpg)「大、大概就像這樣......」

......

呃，好，咱大概懂了，這真是一椿悲哀的意外。不過這個話題和我無關，完全無關，就此跳過吧。

今天要帶給大家的主題有兩大項。

首先擋在面前的是「粒子系統」。在這個主題中，咱們會聊到如何使用大量的小圖片來創造動畫。至於第二個，則是動態的圖片修改器 "Image Manipulators"。

前者能讓您大量創造像是「雨水落下」一類的畫面效果。至於後者，則能讓遊戲無需預存圖片的全部版本－－只需保存少少幾張圖，與之相關的衍生版本（如一張背景圖可能有多種打光變化）就能透過即時算圖自動搞定－－這不光是節約儲存空間，也可減少您需要管理的圖片總量，是相當方便的功能。


(http://www.openfoundry.org/images/130226/renpy7/Head_Info_1_5.jpg)「雖然程式碼確實不少，但本回的內容遠遠沒有上回那麼繁瑣。請不要被上回嚇倒倒了。」

(http://www.openfoundry.org/images/130226/renpy7/Head_Secure_1_4.jpg)「那麼，這就開始吧！」


Sprite 粒子系統

照慣例，最難的東西放在最前面－－今天就從粒子系統開始。

要讓畫面上出現一大堆，具有隨機動畫的相似小圖片（比方說水花、雨點、雪片、花瓣等等），一張張貼圖、手工寫 ATL 做動畫這種事，多半不是個好主意。畢竟結局我已經見到了：「少女（年）伏在桌上，臉上帶著一絲笑容，彷彿睡著了那般，靜靜地陷入了永眠」－－世界線變動率 怎樣也無法超過一啊！

一言以蔽之，會累死的。

雖然說過勞死也是遊戲製作者的本職學能，不過如此一來，會給社會版記者造成很大的困擾，還請不要那麼做。

為了減少社會版記者......不對，應該說各位遊戲作者的麻煩，Ren'Py 提供了相當不錯用的 Sprite 系統。

如前所述，Sprite 系統能在畫面上隨機顯示很多小圖片，並附上相應的移動特效......像雪花或櫻花紛紛飄落這種效果，用本系統就能輕易做到。

(http://www.openfoundry.org/images/130226/renpy7/renpy_07_01_sprite.jpeg)
▲ 圖：官網對粒子效果的示範之一－－讓多片櫻花瓣從邊緣的隨機位置，以隨機的速度與方向飄落。以上這種簡單的粒子效果，用 SnowBlossom() 函式就能創造出來；稍後會有示範的，請別著急。另一方面，圖上標出的 Sprite 就是 Ren'Py 粒子系統中的「粒子」了。

走囉！


 【Sprite 與 Particle 的用語解說】 

說到這裡，我已經聽到有熟悉遊戲引擎設計的同學在慘叫了。
－－「不對......不對不對不對！"Sprite" 再怎麼翻譯也不會變成『粒子』，粒子系統應該是 Particle System 才對。Sprite 系統明明是別的東西。這兩者在遊戲引擎的世界中是完全不一樣的呀！」
啊啊，非常遺憾，您的說法完全正確。在一般的遊戲引擎中，Sprite 確實是被翻成「精靈系統」而非「粒子系統」，而其功能也和我們這邊要講的粒子系統完全不同。
但我也沒說錯！Ren'Py 引擎中，就是將粒子系統命名為 Sprite，我也沒辦法啊！這都是世界的錯！
(http://www.openfoundry.org/images/130226/renpy7/Head_Info_1_9.jpg) 音符：「不，世界是無辜的......」

咳！誰的錯先不管。那麼在一般的遊戲引擎中，Sprite 系統（精靈系統）又是指什麼呢？
一般來說，Sprite 是指一個「2D 圖片的容器」。
這個容器具有自己的長寬大小、具有在螢幕上的座標位置、甚至具有自己的旋轉角度、透明度等等。但是這個容器實際顯示些什麼，卻不是由容器自己決定，而是由容器中裝入的圖片來決定。
......聽起來似乎很熟悉？之前好像用過這個概念？
是的！之前我們操控立繪時，Sprite 的概念確實早就已經包含於其中了。

以下是一段連續的圖片操作。您可以試試看，看看自己認不認得出來，一般遊戲引擎中所謂的 Sprite 究竟是哪一部份？

show elminster smile
show elminster at right
show elminster at left
show elminster:
    alpha 0.5
show elminster confuse
show elminster at center with ease


......答案是 "elminster" 這個標籤 (tag)。之前我們將其稱之為「圖片名稱中的第一字節」，不過（僅管 Ren'Py 官方沒有這麼稱呼），事實上它就是其他遊戲引擎中會見到的那種 Sprite。

注意：前面的解說乃是針對一般遊戲引擎的補充，而非針對 Ren'Py 的。如果您感到非常困惑甚至開始混淆，那麼請把這部份的內容忘光光。這對後續的說明沒有任何影響。


知道粒子系統是什麼後，就從最簡單的開始吧。

SnowBlossom(...)

如果您只是想要櫻花、雪花紛紛飄落的那類效果，您可以直接使用「SnowBlossom()」 (http://www.renpy.org/doc/html/sprites.html#SnowBlossom) 函式來創造。如下：

image snowflakes = SnowBlossom("snowflake.png")     # 定義雪片飄飄落下的效果
                                                    # 注意：這其實也是一張圖片 (image)。

label start:
    scene black         # 黑底
    show snowflakes     # 顯示飄落效果

(http://www.openfoundry.org/images/130226/renpy7/snowflake.png)
▲ 圖：上例中的 snowflake.png 圖片，每一片飄下來的雪片都長這樣。如果您希望粒子系統中包含多種 snowflake，可以用 ATL 的 choice，或多個 contains 搭配多個 SnowBlossom() 試試。請見後續的範例。

(http://www.openfoundry.org/images/130226/renpy7/renpy_07_02_snowblossom_snowflake.jpeg)
▲ 圖：螢幕效果示範。有部份雪片破碎是因為截圖時沒有垂直同步的關係，並非真正顯示成那樣。

非常簡單吧？

上例中的 "snowflake.png" 只是一張簡單的雪結晶圖片，不過您也可以將其設為任意 Displayable。

因為其他參數都沒設定，所以保持著預設值。比方說，雪花在螢幕上的片數就被預設為 10 片，而顯示效果則是隨機往下飄，且會模擬微風從左往右，輕輕吹拂的感覺。

SnowBlossom() 中可變更的重要參數包括......


＊count
    改變 displayable 的一次出現數量。預設為 10。
＊xspeed、yspeed
    設定 displayable 在 x 軸與 y 軸的移動速度。
    無論是 xspeed 或 yspeed，都可分別輸入一個二元 tuple，如 (20,50)，表示 displayable 在這個軸上的可能速度範圍。創造畫面上不同的 displayable ，移動速度與方向都不同的隨機效果。
＊fast
    設為 False，表示剛開始顯示時，displayable 會從邊緣飄出；反之設為 True 時，從一開始，大量 displayable 就會直接顯示在螢幕中間，突兀地瞬間出現。預設為 False。

SnowBlossom() 還有些別的參數，不過個人覺得那些參數可有可無，無需理會。完美主義者請見官網說明頁 (http://www.renpy.org/doc/html/sprites.html#SnowBlossom) ，自行對照參考。

以下是一個用 SnowBlossom() 創造的「灰塵隨機飄散」效果。－－咱這邊還一併用上了第六章提過的 ATL，請務必參考看看。

# 定義大小灰塵，共四種大小。

image mmsprite middle:
    "dust.png"
    zoom 0.75

image mmsprite small:
    "dust.png"
    zoom 0.5

image mmsprite vsmall:
    "dust.png"
    zoom 0.25

image mmsprite vvsmall:
    "dust.png"
    zoom 0.1



# 漂浮的灰塵效果。這是一個 ATL 區塊，

image dust:
    # 本區塊內有四個獨立的 SnowBlossom，我把它們打包成一個 dust。

    # xspeed 有正有負，表示灰塵可往左或往右飄；而 yspeed 亦同。這裡的速度想當然爾不能設太大，不然就不像是灰塵了……
    # fast 表示剛 show 圖時，螢幕上就會立刻堆滿灰塵。否則，灰塵會慢條斯理（真的很慢）地從畫面最邊緣慢慢湧現出來。

    contains: # 最小（遠）的灰塵數量最多，count 有 30。
        SnowBlossom("mmsprite vvsmall", count=30, xspeed = (-20, 20), yspeed = (-20, 20), fast = True)

    contains:
        SnowBlossom("mmsprite vsmall", count=20, xspeed = (-20, 20), yspeed = (-20, 20), fast = True)

    contains:
        SnowBlossom("mmsprite small", count=10, xspeed = (-20, 20), yspeed = (-20, 20), fast = True)

    contains: # 最大（近）的灰塵數量最少，count 只有 5。
        SnowBlossom("mmsprite middle", count=5, xspeed = (-20, 20), yspeed = (-20, 20), fast = True)


# 使用方法一樣

label start:
    scene background  # 顯示背景
    show dust         # 顯示剛剛定義好的灰塵
    with fade

看到了嗎！ATL 可是萬用大殺器啊！就算搭配粒子系統也能運作得很好。最好去習慣使用它，這樣才不會吃虧。

(http://www.openfoundry.org/images/130226/renpy7/Head_Secure_1_7.jpg) 「ATL 是第六回的主題，忘記內容或嫌太難而跳過的笨蛋們，請一定要回去複習唷！」

以上發言不代表本台立場！絲蔻兒......光裝可愛是不夠的，控制一下妳的毒舌，算我求妳......

自訂 Sprite 效果

如果您需要一些連 SnowBlossom() 也不能滿足的超特狂暴粒子效果，那就需要用 SpriteManager 物件寫 Python 程式碼了。

這部份扯到物件，程式碼不少，對初接觸物件的人可能稍微有點難度。如果真的看不懂，各位暫時跳過也沒問題。願意挑戰的同學，這就請聽在下的解說吧。坐坐坐。


【物件 (object)】 
前面提到「SpriteManager 物件」，那麼，這邊所說的「物件」到底是什麼呢？

以我們人類的觀點來說，物件是一個「嚐試去模擬現實的東西」。
比方說一個叫「主角」的物件中，可能會有......
　　＊一些資料：好比像是「身高 = 172」、「體重 = 63」、「個性 = 善良」、「名字 = 雪風」等等。
　　＊一些動作：好比像是「對話」、「拿取」、「戰鬥」之類的。

當然，這種模擬並不完備，但也不需要完備。
比方說，如果您的遊戲中沒有戰鬥，那麼又何必為角色設計「戰鬥」這種行動呢。如果角色的血型與身高從不會出現，對遊戲毫無影響，那當然也無需記錄這份資料。事實上，需要列入模擬的東西通常很少也很有限。
......以上的說法，是以我們「人」的觀點來解釋物件。
不過真要說，以程式的觀點來討論物件，卻也相差不多；主要的差異在於，前述的「動作」，在程式的世界中是以「函式 (function)」來呈現的。
而物件，就是一個「將資料，與處理資料的函式，打包綁在一起的程式元件」。

創建物件的方法有很多，但通常我們會先有一個用來製作物件用的「樣板」（在程式中稱此為「類別」）。

比方說，假如我想創造主角這個角色，我可能得先有一個「角色」的類別。
您可以把「類別」想像成一張「空白的表格」，而不同的類別就是不同的表格。您在角色的表格裡面填入名字、血型、個性、生日等資料......就能把這個角色給製作 （模擬）出來。而日後，當這個角色進行一些共通的行動－－比方說「自我介紹」－－時，因為之前填入的東西不同，當然就會得出不同的結果了！

以物件來模擬現實，這程式寫法叫做「物件導向」，算是當前世界上最主流的幾種程式寫法之一。
此處解釋得很簡單啦，想知道更多，還請自行查查資料吧。

一言以蔽之，粒子系統是由「Sprite」與「SpriteManager」兩種類別構成的。

＊SpriteManager 是粒子系統的核心，首先必須要有它，才能管理「一整套粒子系統」的運行。
＊至於 Sprite，則表示著一套粒子系統中的每個個別粒子。如前例中的雪花，每一片單獨的雪花都是一個單獨的 Sprite。

粒子系統是以 SpriteManager 為基本單位來使用的。個別的 Sprite，會由 SpriteManager 透過 SpriteManager 物件內部的 .create(displayable) 方法建立。每建好一個 Sprite 物件，我們都該設定好那個 sprite 物件的初始位置（sprite.x 和 sprite.y）。之後再將 SpriteManager 創造出的 Sprite 們，全部儲存到一個列表 (list) 中，如此一來，日後就可以利用各位自己親手寫的「更新函式」，對列表中的所有 Sprite，進行位置變更動作。

總之，建立一個自訂的 Sprite 系統，大略流程如下：

1.自訂一個 spriteList = []，用來儲放全部的 Sprite 物件資料。通常實際使用時 Sprite 物件總數會有幾十個到幾百個之多。
2.自訂一個 updateFunction(st) 函式。這個函件將在 Sprite 們通通建立好後，用來更新所有 Sprite 物件的資料。 
。這個函式的名字（即前述的 updateFunction 部份）怎麼取都沒關係，不過其中：
    *唯一引數 st：代表從「第一次呼叫算起」，到現在所經過的時間。單位為秒。
    *函式本身的工作是依據時間差，更新全部的 sprite 的狀態。
    *這裡說的「狀態」，主要是指「位置」……當然您也可以順便改些別的東西。請隨意。
    *函式回傳一個時間（單位：秒），說明再過多久後要再次呼叫進行更新。
    *通常 return 0 就可以了。表示以盡可能最快的速度來更新。
3.用語句 sm = SpriteManager(update = updateFunction) 建立一個 SpriteManager。
。updateFunction 就是就是您之前那個更新函式的名字。
4.透過新建立的 SpirteManager 物件，執行 sm.create() 大量建立 Sprite 物件，把目前還空著的 spriteList 填滿。同時，也別忘記對這些 Sprite 物件的狀態進行初始化。

－－很有點複雜對吧？

以上內容，第一次看看不懂是很正常的。請對照下面的特大號範例一起看。

「官網的範例」 (http://www.renpy.org/doc/html/sprites.html#sprite-examples) 中，直接使用了這一整套流程，搞得腳本之中散滿亂七八糟的程式碼，烏煙瘴氣。不過在官方 tutorial 示範遊戲中，卻有把這些流程封裝在物件裡，因此程式本身就好看且方便很多、而資源管理也容易了不少。我個人強烈推薦使用物件模式，因此下方的範例，也是以 tutorial 中的程式碼為範本來介紹（註解當然是我寫的）。

為了理解方便，強烈建議各位在繼續往下看之前，先去執行一下官方 tutorial 範例遊戲，看看以下這坨東西到底會產生怎樣的結果－－只要在 tutorial 的選單中，選最下方的 "Sprites" 選項就能看到。

見識過效果了嗎？那我們來看看程式怎麼寫吧......請深呼吸。這是本回最難的範例了。

init python:

    # 建立一個名叫 StarField 的新類別。
    # 最前面的 class 是新定義一個類別時，必定要用的關鍵字，不能改動。後面的 (object) 另有意義但暫時說不清，總之也不要去變更它。
    class StarField(object):

        # 以下是 StarField 這個類別內部包含的東西的定義
        # 一言以蔽之，總共包含三個函式：__init__()、add()、update()。

        # 先定義 __init__() 函式。__init__() 函式決定了，透過本類別新建一個物件時，到底要怎麼做初始化設定的。
        # 引數中的 self，是在表示日後用本類別創造出來的物件自身。（註：在 Python 類別中定義的函式，第一個引數大多是 self。透過物件使用時本函數時也不用特意傳入這個引數，Python 會自動幫您連結好。）
        def __init__(self):
            # 我們要在 __init__() 中初始化 SpriteManager 與 spriteList，並把 spriteList 填滿

            self.sm = SpriteManager(update=self.update)  # 初始化 SpriteManager，並命名為 self.sm（也就是 self 物件的子物件 sm）。
                                                         # self.update 是什麼？其實就是本類別內部定義的三個函式之一的 update 函式。之後會有定義的。不說這個，比起來，您稍微感覺出 self 的用法了嗎？

            self.stars = [ ]                             # 這就是前述的 spriteList。名字差異不重要啦。
                                                         # 目前是空的，我們等會得填滿他。

            # 開始填入 spriteList，有好幾種不同的 displayable

            d = Transform("star.png", zoom=.02)   # 第一種 displayable，主要只是改變大小……
                                                  # 這邊的 Transform() 做的事情，其實和我們前面（第六回）花了大篇幅講過的 ATL 沒有不同。只是 python block 中不能用 ATL，所以才用這種寫法。
                                                  # Transform() 的使用說明見此：http://www.renpy.org/doc/html/trans_trans_python.html#Transform
            for i in range(0, 50):                # 用 for 迴圈重複填入五十個相同的 displayable 到 spriteList 中。
                # 下面的 add() 是輔助程式。工作只是呼叫 self.sm.create()，並將產生出的 Sprite 的位置初始化後，放入 self.stars。您可以先往下找來看看。
                self.add(d, 20)                   # 20 是速度，模擬愈遠方（小）的星星移動的愈慢

            # 繼續變更 displayable，設成其他大小……
            d = Transform("star.png", zoom=.025)  # 星星的大小變大了
            for i in range(0, 25):
                self.add(d, 80)                   # 比較大的星星，移動速度也比較快了。

            # 下面以此類推……
            d = Transform("star.png", zoom=.05)
            for i in range(0, 25):
                self.add(d, 160)

            d = Transform("star.png", zoom=.075)
            for i in range(0, 25):
                self.add(d, 320)

            d = Transform("star.png", zoom=.1)
            for i in range(0, 25):
                self.add(d, 640)

            d = Transform("star.png", zoom=.125)
            for i in range(0, 25):
                self.add(d, 1280)

            # 所有的 sprite 都建立完成，以後不會再呼叫 self.add() 與 self.sm.create() 了。

        # 定義 add()：用來加入並初始化粒子的助手函式
        def add(self, d, speed):
            s = self.sm.create(d)                  # 透過 self.sm.create 產生 sprite。sprite 一定要透過 sm (SpriteManager) 的 .create() 來產生。
            start = renpy.random.randint(0, 840)   # 在顯示範圍寬度的區域內，隨機生成 x 軸起點
            s.y = renpy.random.randint(0, 600)     # 在螢幕高度的範圍內，隨機生成 y 值
            self.stars.append((s, start, speed))   # 將 sprite （連同更新時所需要的附屬資料，如移動速度一起）塞入 spriteList（本例中就是 self.stars）中。
                                                   # 由此可知 sprite 中每個元素的格式都為一個三元元組，其中記錄了三份資料：(用來顯示的 sprite 本體, x 軸起點, x 軸平移速度)
       
        # 定義 update()：更新位置用的函式
        def update(self, st):
            for s, start, speed in self.stars:   # 用 for 迴圈處理整個 self.stars (spriteList)。self,stars 中，每個元素又可被拆開為三個部份（見 add() 中的說明）
                # 算法：x 新值 = (x 初值 + 速度 * 經過總時間) 取顯示範圍寬度的餘數 - 20
                s.x = (start + speed * st) % 840 - 20
            return 0                             # 不等待，以最快速度進行更新


# StarField 類別定義到此結束，接下來是呼叫示範


label start:
    scene black      # 只是設為黑底。記得嗎？我們剛剛定義的 StarField 沒有定義任何底色。
    show expression (StarField().sm) as starfield   # 靠這句顯示粒子效果


    # ======== 上一句的說明 ==========
    # 上面是一個普通的 show X as Y 語句。不過 X == expression (StarField().sm)
    # expression (...) 表示括弧中的內容是 python 語句－－要 show 的東西不用 renpy 腳本語法，而是直接用 python 語句表示。
    # 而 StarField().sm 這個 python 語句，意思是用 StarField 類別建立一個全新的 StarField 物件（之前辛苦定義的 __init__() 會在此時執行完畢），並用 .sm 標示新的 StarField 物件內部的 sm （SpriteManeger 子物件）－－這個 sm 很重要，因為它就是 show 要顯示的目標物。
    # 總之，要顯示的目標是 SpriteManager 物件，而非 StarField 物件。請注意這個差別。
    # 最後的 as starfield，則是用在事後消除上，最好也給一下。
    # ======== 上一句的說明 ==========


    with wipeleft         # 同時套用到上面兩行的轉場特效。
    "StarField 顯示中……"

    hide starfield        # 將 starfield 消掉


瘋狂吧。至少我的手快給打斷了。

不管怎麼說，到此您應該能順利自訂 Sprite 系統了。

SpriteManager() 還有些其他參數可以輸入：比方說創建時可以輸入一個 event function，每當 event 發生就會被呼叫......另外也可以自定義 width 與 height 屬性，讓 SpriteManager (http://www.renpy.org/doc/html/sprites.html#SpriteManager) 只包括有限的長寬而非全螢幕等等，諸如此類。詳情請見 SpriteManager 的說明。至於 event 的使用，則請參考官網範例 (http://www.renpy.org/doc/html/sprites.html#sprite-examples) ，其中有用到這個功能，不過我們這邊不講。我看到有些同學頭上已經在冒煙了......

夠啦，Sprite 系統實在太殘暴了！這根本就是在踐踏我們對遊戲的愛！身為主持人我也快受不了了，快來點簡單點的......

(http://www.openfoundry.org/images/130226/renpy7/Head_Info_1_10.jpg) 「那、那個，簡單是相對而言啦......」

總之請看！


Image Manipulators 圖片修改器

雖說「修改器 (manipulator)」這個名字聽來讓人有些困惑，不過從技術上說，Image Manipulator （以下簡稱 IM）只是 Ren'Py 的世界中，眾多 Displayable 的一種。您可以在所有可使用 Displayable 的地方利用它，就和利用普通的 Displayable 一樣。

忘記 Displayable 是什麼的同學，請參看第六回。

它的最大特徵在於：當它生成時，需要以一張圖片 (Image)，或一張現有的 IM－－做為原料。

注意：一定要是「圖片或 IM」，才能做為 IM 的原料。如果您企圖用其他類型的 Displayable－－如 Solid－－來產生 IM，Ren'Py 也會用華麗的錯誤畫面來糾正您的。

喔對了，因為 IM 可接受 IM 做為原料，故您也可以將多個 IM 嵌套使用。

如同它的名字，「圖片修改器 (IM)」可讓一張圖片，透過各種各樣的數學運算，被修改成另一張不同的圖片。比方說，裁切出一部份、變更色調、翻轉、組裝多張圖片等等。而這個被修改過的新圖片，可以用在任何「可擺放圖片」的地方。

IM 做出的東西，每一份都是完整的圖片，因此，任何一個功能比較完善的圖片編輯器（如 Gimp 那種），都能替代它，做出同樣甚至更好的效果。而且因為它的本質是「圖片」，所以 IM 也不支援插值動畫，具體說來，您不能併用 ATL 與 IM 來平滑地過渡色相環，只能喀地一下切換過去。

因為上述種種限制存在，所以 IM 不像前回的 ATL 那樣激動人心、不可取代。

它只是一個補充，用在「有很多相似但不同的圖片」要顯示，但又不想實際將這些圖片保存在硬碟之中時。

那麼以下，依照咱對這些 IM 的理解，為各位介紹各種可能用的上的 IM......


im.AlphaMask(base, mask)

輸入兩張圖片 "base" 與 "mask"，用 mask 來調整 base 的透明度。最後顯示出的圖片是經過透明度調整後的 base 圖。

調整的方法是：用 mask（遮罩圖片）的「紅色 channel」來取代 base（內容圖片）的 alpha channel。


【alpha channel】 
就是透明度通道的意思。

alpha channel 的數值越大（越接近百分之百），則越「不」透明。


舉例來說，如果 mask 圖片中塗滿紅色，表示 base 圖片全不透明（會完全顯示出來）。

用法如下：

image memory = "bg/memory.png"                     # 回憶畫面
image spot light center = "effect/red_center.png"  # 中間紅周圍白的圖片

image memory fuzzy = im.AlphaMask(base = "memory", mask = "spot light center")  # 周圍消去的回憶畫面

label start:
    scene black with dissolve
    show memory fuzzy with dissolve
    "這是去年夏天，在那個滿是蟬鳴的小水塘邊發生的故事......"


(http://www.openfoundry.org/images/130226/renpy7/memory.jpg)
▲ 圖：memory.jpg 示意圖。本圖做為 base 使用。

(http://www.openfoundry.org/images/130226/renpy7/Head_Secure_1_5.jpg)「......這傢伙是誰啊？」

只是我的好姬友......喂喂！不要打那種無謂的岔！

(http://www.openfoundry.org/images/130226/renpy7/red_center.jpg)
▲ 圖：red_center.jpg 示意圖。本圖做為 mask 使用。需特別留意「不顯示的地方要設為黑色（而不能設為白色）」。您可以想想為什麼。

(http://www.openfoundry.org/images/130226/renpy7/renpy_07_03_welcome_alphamask.jpg)
▲ 圖：以黑色為底色時的顯示成果。


im.Composite(...)

將多張圖片合成一張。

這有什麼用？官網提供的範例是有趣個的解答，快看下面！


image girl clothed happy = im.Composite(
    (300, 600),                                            # 合併後的圖片大小為 300 x 600
    (0, 0), "girl_body.png",                         # 第一張圖（底圖）：少女身體圖片，放置位置（左上角位置）為 (0,0)
    (0, 0), "girl_clothes.png",                      # 第二張圖：衣服
    (100, 100), "girl_happy.png"                 # 第三張圖：表情
    )

......這不就是紙娃娃系統嗎！

有沒有燃燒起來的感覺啊？我第一次看到時可是很興奮的。


事實上，若不考慮記憶體消耗，第六回的 Fixed 也可以做到同樣效果。然而 Fixed 所用的介面比 im.Composite() 要抽象，此時直接用 im.Composite() 會更方便一些。



im.Grayscale(im)

輸入一張圖片，輸出一張去飽和度後的，黑白版本的圖片。

image world normal = "world.png"              # 普通圖片
image world gray = im.Grayscale("world.png")  # 黑白圖片

(http://www.openfoundry.org/images/130226/renpy7/renpy_07_04_library_normal.jpg)
▲ 圖：這是之前第三回時就用過的 library.jpg 圖片，由 Uncle Mugen 原作，我稍加修改後製。接下來就以這張圖作為範本嚐試改變顏色。

(http://www.openfoundry.org/images/130226/renpy7/renpy_07_05_library_grayscale.jpg)
▲ 圖：im.Grayscale() 的效果。

(http://www.openfoundry.org/images/130226/renpy7/Head_Secure_1_2.jpg)「原來最近的泰克斯也做了 Grayscale 處理呀。」

(http://www.openfoundry.org/images/130226/renpy7/Head_Info_1_6.jpg)「那個嗎，我覺得好像不是......」

跳過，快跳過這個話題啦！

請繼續看。


im.Sepia(im)

輸入一張圖片，輸出一張有舊照片效果的圖片。

image world normal = "world.png"               # 普通圖片
image world Sepia = im.Sepia("world.png")  # 泛黃圖片

(http://www.openfoundry.org/images/130226/renpy7/renpy_07_06_library_sepia.jpg)
▲ 圖：im.Sepia() 的效果。

什麼，您嫌 im.Sepia() 還不夠黃？太黑了？

請先等等，在後面，咱會提供一些進階的調整辦法......

可被替代的 IM

官方還有提供一些像是 im.Crop()、im.FactorScale()、im.Scale()、im.Flip()、im.Tile() 等的 IM。

關於以上這些東西，個人覺得沒啥使用價值，但還是稍微介紹一下好了。

＊im.Crop()
    可從一張大圖中，切出一部份做為小圖。
    －－因為在 ATL 中也有相同功能的 "crop" 屬性可設定，所以沒有使用的必要。
＊im.FactorScale()
    可依比例縮放一張圖片。
    －－在 ATL 中可以用 "zoom", "xzoom", "yzoom" 三個屬性取代它的效果。
＊im.Scale()
    可依絕對大小（像素數）縮放一張圖片。
    －－在 ATL 中可以用 "size" 屬性取代它的效果。
＊im.Flip()
    可水平或垂直翻轉一張圖片。
    －－自從 6.14 版後，只要將 xzoom, yzoom 的數值設為負值，也可達到翻轉的效果。
＊im.Tile()
    可用小圖片拼磚拼出一幅大圖片。
    －－不過第六回提過的 displayable: LiveTile 也能達到同樣的效果。

以上的 IM 操作，大多用 ATL 等其他方法，也能達到相似的效果。因此沒有勉強使用的必要。

不過，儘管效果雷同，底層的實作方式卻略有差異。IM 一律是「預先」產生一張完整的修改版本圖片，ATL 則更多是臨時性的修改－－這些差異，可能會反映在遊戲的執行效率與記憶體消耗上……總之如果用 ATL 的執行效率明顯不夠好時，您還是可以用以上這些 IM 試試，看能否得到更好的效果。


【更多的 IM】 
如果您完整看過官方的 tutorial 遊戲，您可能會注意到，Ren'Py 中其實還有「更多的 IM」可用。只是咱這邊沒講。那些零零碎碎的 IM 沒被寫入 Ren'Py 的新版官方手冊之中，顯然已經不再被官方繼續推荐使用，而且那些功能，也大多都可以被下面所要介紹的 im.MatrixColor() 所取代。

如果您真有興趣，想找它們的資料，請用 "im" 關鍵字去搜索官網 wiki (http://www.renpy.org/w/index.php?title=Special:Search&search=im&go=Go) ，會發現不少的。


im.MatrixColor(im, matrix)

本節的重頭戲要來了，請深呼吸。

前面提過 im.Sepia() 和 im.Grayscale() 可以把圖片變成舊照片與黑白圖片－－那麼，有沒有可能將圖片改成其他顏色呢？

答案是可以的。

您可以透過矩陣，將圖片中的某些顏色加深，或平移色相，或濾去顏色，或增加亮度......幾乎無所不能！


原理

im.MatrixColor 所用的顏色轉換矩陣（由我們這些遊戲作者給出），格式應該要像下面這樣：

[ a, b, c, d, e,
  f, g, h, i, j,
  k, l, m, n, o,
  p, q, r, s, t ]


它在圖片顏色轉換的意義上，是被這樣表述的：

R' = (a * R) + (b * G) + (c * B) + (d * A) + e
G' = (f * R) + (g * G) + (h * B) + (i * A) + j
B' = (k * R) + (l * G) + (m * B) + (n * A) + o
A' = (p * R) + (q * G) + (r * B) + (s * A) + t



＊小寫英文字母，對應到我們所給的顏色轉換矩陣。
    －－範圍通常在 0.0 到 1.0 之間，不過官方沒有嚴格規定。（我想某些狀況下 -1.0 ~ 0.0 也是合理的數字）
＊R、G、B、A 代表「原始圖片」的紅 (Red) 綠 (Green) 藍 (Blue) 不透明度 (Alpha) 四條顏色通道的數值。
    －－範圍在 0.0 到 1.0 之間。其具體數字，取自於您當前所要處理的圖片。
＊等號左邊的 R'、G'、B'、A'，代表「新圖片」的紅 (Red) 綠 (Green) 藍 (Blue) 不透明度 (Alpha) 四條顏色通道的數值。
    －－範圍同樣在 0.0 到 1.0 之間。如果運算後超過這個範圍，會被自動修正到 0.0 ~ 1.0 的範圍內。


這個方程式是什麼意思呢？

事實上，以上的方程式，是用來對「圖片上的每一個單獨像素」做運算用的－－假設有一張 800 x 600 大小的圖片，圖片上就有 800 x 600 = 480000 個像素點，要分別做 480000 次上面這組計算。


【註】 (http://www.openfoundry.org/images/130226/renpy7/Head_Info_1_1.jpg) 音符：「每個像素都有自己原本的 RGBA 顏色值。如紫羅蘭色的像素點，其 RGBA 為 (0.93, 0.51, 0.93, 1.0)、而橄欖色的像素點為 (0.5, 0.5, 1.0, 1.0) 等等。」


R' = (a * R) + (b * G) + (c * B) + (d * A) + e

新的紅色強度 = (a * 原紅色強度) + (b * 原綠色強度) + (c * 原藍色強度) + (d * 原不透明度強度) + e

很明顯地，新紅色的最終強度，受到舊顏色的四條通道與一個常數 (e) 的共同影響。

如果希望新舊紅色強度不改變（新紅色強度 = 舊紅色強度），則矩陣的 abcde 中，a 設為 1.0，bcde 都設為零，這樣就可以了。

除了紅色以外，其他通道的狀況也相同：

R' = (a * R) + (b * G) + (c * B) + (d * A) + e
G' = (f * R) + (g * G) + (h * B) + (i * A) + j
B' = (k * R) + (l * G) + (m * B) + (n * A) + o
A' = (p * R) + (q * G) + (r * B) + (s * A) + t

新的紅色強度 = (a * 原紅色強度) + (b * 原綠色強度) + (c * 原藍色強度) + (d * 原不透明度強度) + e
新的綠色強度 = (f * 原紅色強度) + (g * 原綠色強度) + (h * 原藍色強度) + (i * 原不透明度強度) + j
新的藍色強度 = (k * 原紅色強度) + (l * 原綠色強度) + (m * 原藍色強度) + (n * 原不透明度強度) + o
新的不透明度強度 = (p * 原紅色強度) + (q * 原綠色強度) + (r * 原藍色強度) + (s * 原不透明度強度) + t

由此，如果您希望您的新圖片和舊圖片顏色完全相同，那麼您的矩陣應該會是如下這般：

[ 1, 0, 0, 0, 0,
  0, 1, 0, 0, 0,
  0, 0, 1, 0, 0,
  0, 0, 0, 1, 0 ]


當然實務上，您不可能真的希望新圖片和舊圖片完全一樣。現在我們可以來點變化。

比方說，以下的矩陣可以將紅色強度削弱為一半......

[ 0.5, 0, 0, 0, 0,
  0,   1, 0, 0, 0,
  0,   0, 1, 0, 0,
  0,   0, 0, 1, 0 ]


以下的矩陣可以將圖片的紅色變綠色，綠色變藍色，藍色變紅色......

[ 0, 1, 0, 0, 0,
  0, 0, 1, 0, 0,
  1, 0, 0, 0, 0,
  0, 0, 0, 1, 0 ]


以下的矩陣可以將圖片均勻加亮 10%......

[ 1, 0, 0, 0, 0.1,
  0, 1, 0, 0, 0.1,
  0, 0, 1, 0, 0.1,
  0, 0, 0, 1, 0   ]


如此一來，您應該能看出 im.MatrixColor 能做到什麼，又對什麼無能為力了吧。（所以別指望用它來做高斯模糊，那是不可能的！）


如果您對矩陣運算有興趣，中文維基百科 (http://zh.wikipedia.org/wiki/%E7%9F%A9%E9%99%A3) 在這個題目上寫得很不錯，推荐參考。

使用方法

矩陣本身有點抽象，但 im.MatrixColor() 的使用方法卻很單純。

如下所示：

image 圖片名 = im.MatrixColor(圖片, 矩陣)


示範：

image street bright = im.MatrixColor("bg/street.png",
    [ 1, 0, 0, 0, 0.1,
      0, 1, 0, 0, 0.1,
      0, 0, 1, 0, 0.1,
      0, 0, 0, 1, 0   ]
    )


或用 im.matrix 來顯式產生矩陣物件（先前的程式碼中的矩陣，是用列表 (list) 去模擬的）：

image street bright = im.MatrixColor("bg/street.png",
    im.matrix([ 1, 0, 0, 0, 0.1,
                0, 1, 0, 0, 0.1,
                0, 0, 1, 0, 0.1,
                0, 0, 0, 1, 0   ])
    )


串接運算

用 im.matrix() 顯式產生矩陣物件要多打一些字，那好處在哪裡呢？

其實，顯式產生矩陣物件後，矩陣就能夠進行相乘了。

而把「多個矩陣依序相乘後的結果矩陣」拿給 im.MatrixColor() 產生圖片，和「多個矩陣依序用 im.MatrixColor() 做串接運算」，效果是一樣的。

連續用 im.MatrixColor() 嵌套處理兩次的作法：

init python:
    # 為了程式清晰，把矩陣提前定義出來
    bright = im.matrix([ 1, 0, 0, 0, 0.1,      # 亮度增加 10% 的矩陣
                         0, 1, 0, 0, 0.1,
                         0, 0, 1, 0, 0.1,
                         0, 0, 0, 1, 0   ])

    nored = im.matrix([ 0, 0, 0, 0, 0,         # 去除紅色的矩陣
                        0, 1, 0, 0, 0,
                        0, 0, 1, 0, 0,
                        0, 0, 0, 1, 0 ])

image street bright nored = im.MatrixColor(
    im.MatrixColor("bg/street.png", bright),   # 先套用 bright 矩陣，產生發亮版本的 IM
    nored                                      # 以發亮版本的 IM 為原料，再套用 nored 矩陣，產生最終版本的 IM
)

先矩陣相乘再算圖的作法：

init python:
    bright = im.matrix([ 1, 0, 0, 0, 0.1,      # 亮度增加 10% 的矩陣
                         0, 1, 0, 0, 0.1,
                         0, 0, 1, 0, 0.1,
                         0, 0, 0, 1, 0   ])

    nored = im.matrix([ 0, 0, 0, 0, 0,         # 去除紅色的矩陣
                        0, 1, 0, 0, 0,
                        0, 0, 1, 0, 0,
                        0, 0, 0, 1, 0 ])

image street bright nored = im.MatrixColor(
    "bg/street.png",
    bright * nored                             # 先相乘再交給 im.MatrixColor() 做運算。注意：「矩陣相乘的前後順序，等於串接運算的前後順序」。順序顛倒結果是不一樣的！
)

以上兩種算法得出的最終圖片，是完全一樣，不過第一個方法耗時是第二個方法的兩倍左右。

我不打算在此用數學證明這兩者為什麼相同，不過請相信我吧。

Ren'Py 內建的矩陣產生函式

對於簡單的顏色變化，手工拼湊矩陣長什麼樣是沒問題，但如果有稍複雜一點的需求－－比方說要把色相環旋轉 30 度之類的－－用手拆矩陣簡直是一種將榮耀歸於色彩學的虔誠祭祀行為。不，不要這麼做，Ren'Py 已經內建了一些矩陣產生函式；您可以用這些函式更直覺地產生矩陣，而無需親手替矩陣填數字。

注意，以下這些用 im.matrix 開頭的函式只會產生「矩陣」，而不會直接產生圖片。要真正用它們來產生圖片，您得將這些矩陣套用給 im.MatrixColor() 使用。如下：

image street color_changed = im.MatrixColor(
        "street.jpg",
        im.matrix.hue(30)
    )


那來看看，有哪些矩陣產生函式可用吧！

im.matrix.brightness(b)

改變圖片亮度。

b 為新圖片的亮度之強度，值在 -1.0 ~ 1.0 之間。負數表示變暗，正數表示變亮。

(http://www.openfoundry.org/images/130226/renpy7/renpy_07_07_library_dark.jpg)
▲ 圖：im.matrix.brightness(-0.2) 的效果。

(http://www.openfoundry.org/images/130226/renpy7/renpy_07_08_library_light.jpg)
▲ 圖：im.matrix.brightness(0.2) 的效果。

im.matrix.colorize(black_color, white_color)

用指定的兩個顏色來重新著色。

原圖片的黑色會被著為 black_color 的顏色，原圖片的白色則會被著為 white_color 的顏色。至於其他顏色則會依據以上兩個顏色進行線性插值。

這有點難懂。舉例來說：

＊如果 black_color 傳入全黑的 "#000"，而 white_color 傳入全白的 "#FFF"......
    則圖片不會有任何改變。
＊如果 black_color 傳入全黑的 "#000"，而 white_color 傳入紅色的 "#F00"......
    黑色依然黑，但所有原本有顏色的部位都會染上或深或淺的紅色。原本的白色會變成大紅色。
＊如果 black_color 傳入全白的 "#FFF"，而 white_color 傳入全黑的 "#000"......
    圖片變成負片，等效於 im.matrix.invert()。
＊如果 black_color 傳入全黑的 "#000"，而 white_color 傳入灰色的 "#888"......
    圖片顏色均勻變暗，最白的地方也不會超過灰色。

(http://www.openfoundry.org/images/130226/renpy7/renpy_07_09_library_white2red.jpg)
▲ 圖：im.matrix.colorize("#000", "#F00") 的效果。最白的地方變成紅色，黑的地方依然是黑色。

(http://www.openfoundry.org/images/130226/renpy7/renpy_07_10_library_black2red.jpg)
▲ 圖：im.matrix.colorize("#F00", "#000") 的效果。白的地方依然是白色，黑的地方變成紅色。

(http://www.openfoundry.org/images/130226/renpy7/renpy_07_11_library_white2gray.jpg)
▲ 圖：im.matrix.colorize("#000", "#888") 的效果。黑的地方依然為黑，但最白處只剩下 50% 灰色。

請注意：因為算法限制，用 im.matrix.colorize() 這個方式著色，圖片的色域與對比，只會越著越小！而不會加大！

如果希望著色後將對比重新拉開，還請在著色後，自行用下面會講到的 im.matrix.contrast() 調整一下。

因為功能近似，建議和後面介紹的 im.matrix.tint() 對照參考。

im.matrix.contrast(c)

改變圖片的對比。

其中變數 c 為對比的強度，這個值以 1.0 為中心。當 c 為 0.0 ~ 1.0 時表示對比減小，1.0 以上則表示對比增加。

c = 0.0 表示毫無對比，整張圖會變成灰色的純色。

(http://www.openfoundry.org/images/130226/renpy7/renpy_07_12_library_contrast_05.jpg)
▲ 圖：im.matrix.contrast(0.5) 的效果。

(http://www.openfoundry.org/images/130226/renpy7/renpy_07_13_library_contrast_15.jpg)
▲ 圖：im.matrix.contrast(1.5) 的效果。

im.matrix.desaturate()

去飽和。

意思就是去掉圖片中的所有顏色，讓圖片變成灰階的。和前面介紹過的 im.Grayscale() 效果完全一樣。

im.matrix.hue(h)

旋轉色相環，改變圖片顏色。

h 是色相環的旋轉角度，理論上應該在 0 ~ 360 之間，不過實際上 Ren'Py 對此並無限制－－如果旋轉角度設為 -90 ，就會自動等於 270、設為 450 則會自動等於 90 度......其他均可以此類推。


【色相 (hue)】
色相是色彩學術語。它可以用「角度」來表示一個「不包括飽和度與明度的顏色」。

比方說，紅色是 0 度，藍色是 120 度，綠色是 240 度。
其間所有的顏色，都會隨著角度不同而「連續且漸進」地變化，就像彩虹一樣。

如果還不了解，請看下面的圖就知道了：
(http://www.openfoundry.org/images/130226/renpy7/renpy_07_14_ColorTriangle.jpg)
▲ 圖：取自繪圖軟體 MyPaint 的色相環，環上最右側的白線是目前所選擇的色相（紅色），同時也正好是色相環中角度零度的位置（以此處為 0 度，角度以逆時鐘方向遞增，一圈當然是 360 度）。至於中間的大三角形區域中，所有顏色的「色相」都相同，僅僅只有「飽和度」與「明度」有所不同。



(http://www.openfoundry.org/images/130226/renpy7/renpy_07_15_library_hue60.jpg)
▲ 圖：色相環旋轉 60 度的示意圖。這意味紅色變黃色，綠色變淺藍，藍色變紫色......請參照上面的色相環以此類推。

用色相環改變圖片顏色的技巧，通常只適用於小物品或小部件上。因為大型圖片中，往往會有某些部分的顏色，永遠不該被我們做任何改變－－如人物立繪中的皮膚色，又或背景中的天空藍等等。這些地方要是變色了，玩家會感覺遊戲很 Low 的。（當然存心要做特效時就另當別論了）


im.matrix.invert()

將圖片變成負片。

(http://www.openfoundry.org/images/130226/renpy7/renpy_07_16_library_invert.jpg)
▲ 圖：負片效果。

(http://www.openfoundry.org/images/130226/renpy7/Head_Info_1_4.jpg)「老實說呀，很少有要在遊戲中直接使用負片效果的地方呢。不過，除了直接用負片來創造效果以外，某些比較特殊的顏色變化，矩陣直接算並不容易算。這時各位也可先試著把圖轉成負片來算圖，等算好了之後，再一次反轉回來。」

(http://www.openfoundry.org/images/130226/renpy7/Head_Secure_1_7.jpg)「有時反轉算圖反而會比較容易。算圖算不出來時可參考這招試試啦。」

im.matrix.opacity(o)

調整圖片整體的透明度。

o 為透明度，數值介於 0.0 與 1.0 之間。設為 0.0 表示完全透明，設為 1.0 表示完全不透明。

im.matrix.saturation(level)

重新調整飽和度。

level 為新圖片飽和度的強度。0.0 為最小值，表示把圖片變為純灰階，等同於 im.matrix.desaturate()；1.0 為飽和度等同原圖（不改變）；更高的數值表示增加圖片的飽和度，圖片會變得更鮮艷。

(http://www.openfoundry.org/images/130226/renpy7/renpy_07_17_library_sat03.jpg)
▲ 圖：im.matrix.saturation(0.3) 的結果。飽和度降低到很接近灰階，但仔細看還是有點顏色。綠葉還是綠的

(http://www.openfoundry.org/images/130226/renpy7/renpy_07_18_library_sat20.jpg)
▲ 圖：im.matrix.saturation(2.0) 的結果。飽和度因此而大幅提升，鮮艷到看起來很假......

其實這個函式還有更多參數可設，不過一般人大概是用不到，有興趣者可以去官網 (http://www.renpy.org/doc/html/displayables.html#im.matrix.saturation) 看看。

im.matrix.tint(r, g, b)

本矩陣提供了濾色功能。

tint 的 r、g、b 三個參數，表示三條顏色通道個別的「保留率」－－最大為 1.0 (100%)，最小為 0.0 (0%)。

...... 說起來，本函式其實就是前面介紹過的「im.matrix.colorize(black_color, white_color)」的簡化版，功能等於「im.matrix.colorize("#000", 顏色)」。當然了因為邏輯系出同源，這個矩陣產生函式，也有顏色色域越塗越窄的毛病。

rgb 介面並不特別好用，又失去 im.matrix.colorize() 原本具有的靈活性，故在下是不建議使用本函式啦。當需要著色時，推荐直接用 im.matrix.colorize() 來上色就好。

官方對 IM 的完整說明，可參考這一頁 (http://www.renpy.org/doc/html/displayables.html#image-manipulators)。

請運用想像力來兜組矩陣

im.MatrixColor() 是個很有彈性的東西，發揮想像力可以作出很多不同的色彩調整。

比方說，在下覺得預設的 im.Sepia() 看起來不夠黃而偏灰，讓咱不太滿意......於是就嚐試著做些自訂，讓這個世界變得更黃褐色（？）一點吧。

(http://www.openfoundry.org/images/130226/renpy7/renpy_07_04_library_normal.jpg)
▲ 圖：這是原始圖片。

(http://www.openfoundry.org/images/130226/renpy7/renpy_07_19_library_customsepia_01.jpg)
▲ 圖：因為我只想保留亮度，所以乾脆先全部轉為灰階。就用 im.matrix.desaturate() 或 im.matrix.saturation(0.0) 來處理一下。

(http://www.openfoundry.org/images/130226/renpy7/renpy_07_20_library_customsepia_02.jpg)
▲ 圖：用 im.matrix.colorize("#f00", "#fee")，因應亮度不同塗上濃淡不同的顏色。此處之所以上「紅色」而非黃褐色，是因為 im.matrix.colorize() 直接上黃褐色不太方便－－為何如此很不好解說，總之，不信您大可親自試試。

(http://www.openfoundry.org/images/130226/renpy7/renpy_07_21_library_customsepia_03.jpg)
▲ 圖：用 im.matrix.hue(30)，旋轉色相環 30 度，紅色就變成黃褐色了。不過這飽和度實在太高，看起來嶄新無比，一點也不舊......

(http://www.openfoundry.org/images/130226/renpy7/renpy_07_22_library_customsepia_04.jpg)
▲ 圖：用 im.matrix.saturation(0.3) 將飽和度降下來。以上，這就是我自己發明的泛黃照片效果了。和預設的 im.Sepia() 相比，是否別有一番感覺呢？

程式碼本身很簡單，見下：

image library sepia = im.MatrixColor("bg/library.png",
        im.matrix.saturation(0.0) * im.matrix.colorize("#f00","#fee") * im.matrix.hue(30) * im.matrix.saturation(0.3))  # 四個矩陣連乘


尾聲

那麼，今天的心得就到此告一段落。

這次的節目應該還算好懂，咱為此可是花了不少功夫，各位覺得如何呢？快稱讚我吧（挺胸）。

(http://www.openfoundry.org/images/130226/renpy7/Head_Secure_1_5.jpg)「......我說啊，觀眾在粒子系統那邊就全死光了吧？」

呃？這個、那個......唔，粒子系統確實比較難一點......可惡......別哪壺不開提哪壺啊！......別講這個啦，粒子系統什麼的，那個是例外！

(http://www.openfoundry.org/images/130226/renpy7/Head_Secure_1_1.jpg) 「佔了正文 50% 的東西，你非要說是例外？還真虧你說得出口啊......而且，隨隨便便就說內容很簡單什麼的，要是咱們的觀眾不幸正好沒聽懂，那不是太傷人了嗎？用詞稍微謹慎一點啊！」

呃？......呃呃呃......

(http://www.openfoundry.org/images/130226/renpy7/Head_Secure_1_2.jpg) 「等等......哎呀呀，不會吧！難道你......是在繞彎子說觀眾是笨蛋？......討厭！怎麼能這麼壞心眼呢，真是好可怕的孩子啊。」

......不！不對！不是！我才沒這樣想！......那是妳吧啊啊啊！

(http://www.openfoundry.org/images/130226/renpy7/Head_Info_1_8.jpg)「夠了呀，絲蔻兒......」

(http://www.openfoundry.org/images/130226/renpy7/Head_Secure_1_5.jpg)「耶？才剛要進入真正有趣的地方......」

這到底是哪門子有趣來著......

算、算了！不要再討論這個話題了！

咳嗯！

下回，雪凡與好朋友們的 Ren'Py 遊戲引擎初學心得提示，將會替 Ren'Py 中那堆子繁雜到讓人幾乎崩潰的基本圖形操作，作個大略的收尾。咱會和各位聊聊 Ren'Py 中的圖層觀念、播放影片的方法、Transform 語句的使用等等等......這些項目說起來，都是些小巧簡單到不知該放在哪個單元的瑣碎小物，但丟著不理也不是個辦法......另外本來預定在本回中就要加以說明的自定義轉場，也由此一併順延到下回，下次再聊。

其實說要替圖形主題收尾，Ren'Py 中還有一個與圖形有關的，名叫 screen 的大題目......不過那東西的規模實在有點大，就之後再說了。先讓大夥喘口氣，日後再戰！

收尾的老話還是那麼一句－－

(http://www.openfoundry.org/images/130226/renpy7/Head_Info_1_1.jpg) (http://www.openfoundry.org/images/130226/renpy7/Head_Secure_1_1.jpg) 「下回，敬請期待！」
_______________________________________________________________

■ [自由專欄] 開發者訪談：DOS 已死，FreeDOS 永存

謝良奇／編譯

許多 30 歲以下的人可能從未見過 "C:\>"，更不用提 "A:\>" 了。然而雖然對微軟而言，DOS 在 Windows 95 之後幾乎已成為過去，但這卻不是該作業系統的終點。MS-DOS 依然健在，在嵌入式設備如某些產業控制系統中，仍可見到其身影，還可以從微軟的 MSDN 網站上下載。不過微軟淘汰 DOS 的決定卻加速了替代方案的興起。其中最顯眼的，是 FreeDOS，一套採 GPL 授權的開放源碼 MS-DOS 相容系統。

對於這許多人認為過於小眾的開放源碼專案，其創立者 Jim Hall 表示，至少從下載數量看來，外界對 FreeDOS 還是有很大的興趣。從去年 1 月 1.1 版釋出後，FreeDOS 的下載數已經超過了 37 萬 9000 次，光是今年 1 月 FreeDOS 1.1 的下載數就超過 3 萬 9000 次。由於這只是該專案網站的下載數量，接觸該系統的實際人數應該更多。不少廠商，像是 ASUS、Dell、HP、Intel、Seagate，都有散佈 FreeDOS 各個版本，或釋出基於 FreeDOS 的產品。

如今身為 Minnesota Morris 大學 IT 主管的 Hall，在開始 FreeDOS 專案的 1994 年時，只是 Wisconsin-River Falls 大學的一名物理系學生。該年 6 月，他在 comp.os.msdos.apps 新聞群組發表了 PD-DOS 專案公告。Hall 記得他為專案寫了一篇宣言。他下載了一份 GNU 宣言 (GNU Manifesto) 到電腦裡，但是在下載 GNU 的 'manifesto.txt' 檔案並儲存在他的 DOS 電腦時，檔案名稱因為 DOS 的 '8.3' 限制 （檔名 8 個字元，副檔名 3 個字元） 被改寫為 'manifest.txt'。由於當時他不甚了解宣言 (manifesto) 的意思，就用了改寫後的名稱，因此在他的文章中，宣言就從 'manifesto' 變成了 'manifest'。

Hall 表示他讀到微軟將在新版 Windows 中揚棄 DOS 的消息。當時微軟正在準備其第一個後 DOS 時代的作業系統 Windows 95。在 1994 年他們使用的是 MS-DOS 與 Windows 3.1，Windows 3.1 雖然不錯，但並非完美，他還是喜歡在 MS-DOS 環境工作，不希望被強制改用 Windows。

當時 Hall 已經得知 Linux 的存在，1993 年時他使用過 Linux 的早期版本，不過他還是常常使用 MS-DOS 環境。他想到假如一群開發者透過網際網路一同協作，可以複製出像 Unix 那麼複雜的系統，想當然也可以在更為簡單的作業系統如 MS-DOS 上，辦到一樣的事。

在研究過該作業系統的使用者手冊後，Hall 寫了幾個工具程式以取代 MS-DOS 的基本命令列功能。其他有興趣的開發者也開始加入。Hall 是專案的發起者，也被默認為專案的統籌者，協調所有人的工作並確保擁有共同目標。雖然 Hall 的初衷是 MS-DOS 的公共領域版本 PD-DOS，他和其他成員為確保該系統能維持自由狀態，於是改用 GNU GPL 授權程式碼。

Hall 表示他們一開始先更名為 Free-DOS，不過之後在 Pat Villani  撰寫其書籍 "FreeDOS Kernel - An MS-DOS Emulator for Platform Independence & Embedded System Development - Master OS Development" 時，又再次地更名，將連字符號丟掉改為 FreeDOS。傳言這是因為 Villani 的編輯器不喜歡連字符。

從一開始，此一專案的目的實際上就是作為 MS-DOS 的替代品。Hall 認為他們的確做到了。因為用戶完全可以用 FreeDOS 取代 MS-DOS，而整個系統的運作卻毫無差別。由於 MS-DOS 6 之後 DOS 就沒有改變過，達到上述目標並不困難。例如，你可以在 FreeDOS 上跑 1980 或 1990 年代的 DOS 程式，也可以在 FreeDOS 上安裝經典 DOS 遊戲並享受有趣時光。

從 Hall 的角度看來，該專案的里程碑是他終於能用 FreeDOS 開機，玩 id Software 劃時代的第一人稱射擊遊戲 Doom。FreeDOS 的運用從執行舊 DOS 程式、遊戲，到執行嵌入式系統如收銀機等，以及在個人電腦上用來安裝韌體更新。

在微軟揚棄 MS-DOS 十多年之後，FreeDOS 依舊維持蓬勃發展一事，許多人或許感到驚訝。Hall 表示，的確他們的開發者人數不如十年前那麼多，但他們優秀的開發者社群，仍持續為 FreeDOS 加入新功能。

這套系統在 2006 達到第一版，FreeDOS 1.1 則在去年 1 月釋出。Hall 表示對 FreeDOS 1.2 或 FreeDOS 2.0 的未來抱持希望，特別是當他們開始開發 2.0 版時，他希望能從不同的角度看待 FreeDOS，並思考 DOS 的下一步為何。

對此，他在部落格上丟出許多想法，他問道，如果微軟沒有走向 Windows，DOS 會變成怎麼樣？Hall 想像 FreeDOS '2.0' 會是以 FreeDOS 1.0 為基礎的更現代化版本。但 FreeDOS '3.0' 與之後的版本則應該轉向多工 FreeDOS 模式，並擴充驅動程式支援，特別是網路部分。

然而，他認為挑戰在於如何演進 FreeDOS 而不改變其基礎。因為 FreeDOS 永遠都是 DOS，必須能夠執行 DOS 程式。畢竟，和舊有應用程式的相容性一直都是 FreeDOS 一大賣點。Hall 表示，用戶應該能夠拿舊 DOS 程式安裝在 FreeDOS 上，並且順利執行。

該專案開發團隊擁有二十多名一般貢獻者，以及數位非經常性的貢獻者。Hall 表示有興趣的人可以很容易地參與其中，更補充說，重要的是對於自由與開放源碼軟體來說，並不是只有開發者或撰寫程式，才能有所貢獻。像 FreeDOS 這類專案總是需要有人撰寫文件或回答問題、在各種硬體上進行測試。

Hall 表示對於該社群的偉大成果感到自豪，當他發起 FreeDOS 時，沒想到會有這麼多人參與其中。在這些人當中，他特別提到在 2011 年過世的 FreeDOS 核心創造者 Pat Villani、加入網路與 CD-ROM 支援的 Jim Tabor，以及 FreeDOS 第一個命令列解譯器 FreeCOM 的作者 Tim Norman。

儘管有不少大公司採用並散佈 FreeDOS，Hall 表示該專案並未收到來自這些公司的正式支援。他說他一直記得該專案初期收到過來自 @microsoft.com 郵件位址的電郵。那不是比爾蓋茨或其他你叫得出名字的人，或許是該公司內的程式設計師，或是名實習生。那個人在電郵裡說 DOS 已經結束了，接下來是 Windows 的時代，他不認為 FreeDOS 能夠撐多久。Hall 說，不過現在是 2013 年了，人們依舊在下載並使用 FreeDOS，所以，我想就是這樣吧。


相關網址：

1. 開發者訪談：DOS 已死，FreeDOS 永存
http://www.computerworld.com.au/article/452826/developer_interview_dos_long_dead_long_live_freedos/
_______________________________________________________________

■ [自由專欄] 網站技術發展史

jaceju ／文


前言

這篇主要是對 Web 技術的發展史做一個概略的介紹，讓大家對目前 Web 技術的演變能有初步的認知。

不過製作網站的技術很多，這裡我僅針對瀏覽器、 HTML 、 CSS 及 JavaScript 做粗略的演進說明，細節部份就請大家參考維基百科或其他更深入的資訊。

另外文章內容或多或少會帶有我個人的主觀意見，而我也儘可能透過網路上的資訊作查證，但一定會有錯誤及不足之處，還望大家能夠指正或補足。


1991

HTML 最早是由網際網路 (World Wide Web) 之父 Tim Berners-Lee (http://en.wikipedia.org/wiki/Tim_Berners-Lee) 所發明，而在 1991 年成為公開的文件規範。而該規範並不是 HTML 1.0 ，而是稱為 HTML Tags ；當時的 HTML 主要是用來表達資料，支援的標籤也不多。


1994

HTML 實際上成為規範是從 1994 年由 IETF 制定的 HTML 2.0 開始。這時候 MOSAIC 是市場上主要的瀏覽器。另外這時 CSS 概念被提出，雖然在這之前也已經有人提出樣式的構想，不過還是由 CSS 的層疊概念出線了。


1995

除了 MOSAIC ，1995 年有三個瀏覽器也問市了： Opera 、 Netscape 和微軟的 IE 。而 Netscape 為了能讓網頁可以跟使用者互動，因此找了 Brendan Eich (http://en.wikipedia.org/wiki/Brendan_Eich) 設計一個腳本語言，當時稱為 LiveScript 。後來 Netscape 在與 Sun 合作之後，便將它改名為 JavaScript 。

JavaScript 最初是受到 Java 啟發而開始設計的，目的之一就是「看上去像 Java 」，但它實際上跟 Java 一點關係也沒有。而且早期的 JavaScript 並不是很完整的程式語言，只是用來給網頁開發者作一些動態選單、圖片特效的網頁小程式。


1996

由於 JavaScript 作為網頁的客戶端腳本語言非常成功，微軟推出了 IE 3.0 ，上面搭載了跟 JavaScript 相容的 JScript 。

而後 Netscape 將 JavaScript 提交給 ECMA (歐洲計算機製造商協會) 進行標準化，因而建立了 ECMA-262 標準，也就是 ECMAScript 。

在這之前由 W3C 召開了一次 CSS 討論會，由原提出者 Hakon Wium Lie (http://en.wikipedia.org/wiki/H%C3%A5kon_Wium_Lie) 當做主要技術負責人，於是 CSS 1.0 規格出版；而 IE 3.0 也是第一個正式支援 CSS 的瀏覽器。


1997

隨著 Windows 95 的推出，微軟也將 Internet Explorer 4.0 整合進去，讓作業系統跟瀏覽器核心綁在一起，也造成日後的瀏覽器大戰。

這時 HTML 4.0 被列為推薦規範， ECMAScript 也推出正式的 1.0 版。



1998

CSS 2.0 在 1998 年正式推出，並且隨著 HTML 4.0 支配了網站設計這個領域。而這時 XML 也正式成為 W3C 推薦標準，為後來的 XHTML 開始鋪路。

有鑑於這時各家瀏覽器實作 HTML 及 CSS 有所差異，因此 Web 標準計劃 (The Web Standards Project) 創立了。目的是希望讓網頁在瀏覽器上的呈現能夠有一致性。只要照標準寫的網頁，可以在各家瀏覽器上呈現出一致的效果。

AJAX 的前身技術 XMLHTTP 也隨著微軟的 Outlook Web Access 出現。


1999

到了 1999 年， .COM 泡沫發展到了極致，也是瀏覽器大戰最火熱的時候， IE 5.0 與 Windows 98 第二版的結合開始瓜分了 Netscape 的市場。

這時 HTML 4.01 推薦版本也推出了，跟 HTML 3.2 及 HTML 4.0 相同，它們都是針對已經上市的規格所做的追溯版本。

接下來 W3C 不打算再維護 HTML ，而是把重心轉移到 XHTML 上。


2000

2000 年時，我們平安渡過千禧夜。這時以 IE 5.5 為展示平台的 DHTML 動態網頁技術被大量使用在網站上。

也在這一年 XHTML 1.0 推出了，它的語法要求很嚴格，如果瀏?器用這個規範來看網頁的話，會使得現在很多網站會無法運作。


2001

接下來 .COM 泡沫一個接一個的破了，但 Microsoft.com 靠著 Windows 活了下來。

瀏覽器大戰也由 Windows 內建的 IE 6.0 獲勝，堪稱網站技術史最光明的時期，因為我們只需要專注一個瀏覽器。

XHTML 正式的規範到 1.1 ，不過限制也更為嚴格，連 mime-type 都必須是 application/xhtml+xml 。

也在這一年，由 JavaScript 大師 Douglas Crockford (http://en.wikipedia.org/wiki/Douglas_Crockford) 提出了用 JSON 格式來表達資料內容。


2002

2002 年，這時候的 W3C 打算推出更嚴格的 XHTML 2.0 。

而且 Web 標準意識開始抬頭，很多網站技術的先驅開始推行符合 Web 標準的網站技術。

不過為了照顧高市佔率的 IE 5.5 及 IE 6.0 ，使得許多 CSS Hack 技術不斷地被研究出來。


2003

這時候 IE 6.0 已經獨霸市場，幾乎沒有對手可以相比。在贏得瀏覽器大戰的微軟，開始輕忽網站平台這個領域，他們把重心放在了 .NET ，他們認為這個是次世代的技術。

不過這時候其他瀏覽器廠商開始準備反攻了，他們的武器就是 Web 標準。其中與 Netscape 同時期誕生的 Opera 可以說是 Web 標準的推手。以 Webkit 為核心的 Safari 也正式推出 1.0 版。


2004

Mozilla 因為重新改寫 Netscape 並開放了原始碼，進而在 2004 年推出了 Firefox 1.0 。對於擁抱 Web 標準的開發者來說是個好消息，這使得 Firefox 的市佔率在一推出就出乎預料地高。

這一年 CSS 2.1 草案推出，主要是修正 CSS 2.0 的錯誤，並且去除掉一些瀏覽器沒有實作的功能。

這時 Tim O’Reilly (http://en.wikipedia.org/wiki/Tim_O%27Reilly) 提出了我們所熟知的 Web 2.0 ；因為 Web 2.0 會用到大量的使用者互動，因此這時 JavaScript 又開始被重視了。

但這時候的 HTML 及 CSS 實作實在是太雜亂，又加上 W3C 打算用 XHTML 整治的手段太過激進，因此三家瀏覽器廠商 Apple 、 Mozilla 、 Opera 就跳出來成立了 WHATWG 這個組織。 WHATWG 的目的是把現有的 HTML 實作做一個完整的規範，並且與當代流行的技術做結合。不久，他們就推出了 Web Application 1.0 。


2005

由於 IE 樹大招風，許多木馬及蠕蟲都透過 IE 的漏洞入侵，因此許多瀏覽器用戶轉而投向了 Firefox 的懷抱。

AJAX 這個技術被 Jesse James Garrett (http://en.wikipedia.org/wiki/Jesse_James_Garrett) 正式命名，隨後也被納入 Web 2.0 關鍵技術中，從此網站技術正式邁進 AJAX 時代。


2006

除了 IE 6.0 之外，其他瀏覽器因為起跑很久了，所以幾乎都可以在很小的工作量下就可以符合 Web 標準。但因為 IE 6.0 的核心一直都沒有進步，結果被網站開發者罵到臭頭。微軟也發現 Firefox 逐漸吃掉瀏覽器市場，所以推出了 IE 7.0 。但基本上 IE 7.0 也只是 IE 6.0 的功能加強版，跟 Web 標準落差還是很大。

至於 W3C 的 XHTML 2.0 根本沒有瀏覽器廠商願意實作，所以宣告失敗。

CSS 3 的部份規格已經被某些瀏覽器實作了，而 IE 仍然不直接支援，只能用自家的技術來模擬。


2007

因為 XHTML 2.0 的失敗， W3C 只好回頭接受 WHATWG 所制定的規格，並改稱為 HTML 5 。

HTML 5 時代正式來臨。這也告訴我們：只有被市場所接受的才是贏家。


2008

以搜尋引擎起家的 Google 也利用 Webkit 核心推出了 Chrome 瀏覽器。

這在當時造成了不少話題，很多網站開發者都非常期待 Google 能為網站技術帶來一些新氣象。


2009

許多報告都指出， Chrome 和 Firefox 開始分食 IE 的市場，直到這時微軟才驚覺網站平台的時代來臨了。這時微軟也針對 HTML 5 推出 IE 8.0 ，但支援程度依舊非常落後，不過因為 Windows 7 的關係，使得它還是佔有一席之地。

當然也不是只有 IE 在進步，其他瀏覽器也持續著他們自己的腳步；在 Web 標準上， Opera 一直是先驅，幾乎很多 HTML 5 的特性都是它先實作出來。 Firefox 則是將重心放在外掛套件上面，對 HTML 5 的支援採取保守的態度。而 Safari 也因為使用與 Chrome 相同核心的 Webkit ，所以正在迎頭趕上。

倒是 Chrome 瀏覽器因為其開發版本一直更新的關係，所以正式版本的版號推進速度非常快，讓其他瀏覽器廠商嚇了一大跳。


2011

針對 HTML5 時代的到來，微軟終於趕上了， IE 9.0 可以說是完全重新出發的作品。

瀏覽器大戰又再次開打了，不過戰場不再是在瀏覽器上，而是應用平台。像是 Chrome OS 、 Firefox OS 、 Windows 8 等等，各家廠商都想透過公開或私有的 HTML5 API 去存取裝置原生的功能，表面上看起來是共同推進 HTML5 規範，實際上卻是你來我往，暗潮洶湧。 (本段文字感謝 Kuro (http://www.plurk.com/kurotanshi) 補充)

而 CSS 2.1 也終於定案了，但這只是 W3C 對它主導地位的一點掙扎。這時 CSS 3 早就已經被各大瀏覽器所支援。從這裡可以看出， W3C 的角色其實更像歷史的紀錄者，而非技術的制訂者。


2012

前陣子 WHATWG 的頭頭又出來說話，他們覺得 W3C 是要穩定的規格，而他們則是隨著時代而演進。因此 WHATWG 的 HTML 5 改名為 HTML Living Standard 。

所以接下來幾年可以說是 HTML 5 、 CSS 3 與 JavaScript 的天下了。

不過新的 CSS 構想 (https://speakerdeck.com/stopsatgreen/the-css-of-tomorrow-revised) 已經悄悄地出現了， Web 開發技術也持續在演進中。



參考

＊Hypertext Markup Language (http://www.w3.org/MarkUp/draft-ietf-iiir-html-01.txt)
＊HTML (維基百科) (http://en.wikipedia.org/wiki/HTML)
＊CSS (維基百科) (http://en.wikipedia.org/wiki/CSS)
＊ECMAScript (維基百科) (http://en.wikipedia.org/wiki/ECMAScript)
＊JavaScript (維基百科) (http://en.wikipedia.org/wiki/JavaScript)
＊瀏覽器大戰 (維基百科) (http://zh.wikipedia.org/wiki/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A4%A7%E6%88%98)
＊網路演進 (http://www.evolutionoftheweb.com/?hl=zh-tw)
＊W3C (http://www.w3.org/)
＊The Web Standards Project (http://www.webstandards.org/)
＊WHATWG (http://www.whatwg.org/)
_______________________________________________________________

■ [源碼新聞] iOS 與 Android 的開放源碼 JavaFX 即將到來

謝良奇／編譯

作為 JavaFX 開放源碼軟體釋出中的一部分，Oracle 正在計劃 iOS 與 Android 的開放源碼 JavaFX 移植版本。JavaFX 是 Oracle 用來開發跨平台多樣化網路應用軟體 (rich internet applications，RIAs) 的一套框架，並且預計在未來取代標準 Java 中 Swing GUI 程式庫，作為圖形使用者介面的預設開發方式。

根據 Oracle 的 Richard Bair 表示，針對 iOS 的 JavaFX 在二月中應該就會進行部分初期釋出，其他剩餘部分則預計與 Prism 同時推出。Prism 是仍要透過 Oracle 程序進行釋出的七項專案之一，大部份程式碼會在二月底前開放源碼，至於其他部分會在一至兩個月內釋出。

javafx-font 是唯一仍維持封閉源碼的元件，開發者正與開放源碼 JavaFX 專案 OpenJFX 攜手，發展取代該元件的開放源碼替代方案。Bair 指出該公司更優先修改了建構與測試系統，以便更快速接受外界貢獻。

此次 iOS 與 Android 的移植版本，皆以某個針對 iOS/Android 而尚未釋出的 JavaSE 嵌入式版本為基礎。此一移植的釋出日期則未定。根據 Bair 表示，由於 Apple 不允許 GPL 授權的應用軟體在該公司應用軟體商店上架，因此在 iOS 上的授權還有一些問題。他說，目前看來 OpenJFX 與 OpenJDK 的組合應該能與應用程式綁定在一起，並以開發者的授權加以釋出。


相關網址：
1. iOS 與 Android 的開放源碼 JavaFX 即將到來
http://www.h-online.com/open/news/item/Open-source-JavaFX-coming-for-iOS-and-Android-1802722.html

2. JavaFX Open Source Update
http://fxexperience.com/2013/02/february-open-source-update/
_______________________________________________________________

■ [源碼新聞] Raspberry Pi Model A 在歐洲開賣並規劃跨向全球

黃郁文／編譯

Raspberry Pi 是台只有信用卡大小，但具有完整功能的 Linux 電腦，其於 2012 年末開始以開源方式釋出驅動程式相關的源碼，所以理論上，它可以被運用在任何的電腦裝置上。由於其多功且運作上具有很高的彈性與延展性，所以自開始向外銷售之後，即受到市場很高的矚目與喜愛，定價 35 美金的加強機型從去年到現在，已售出了近百萬台，而較輕簡的 25 美金機型 Model A，近日也於歐洲開賣，並接受北美消費者的線上預購。

Model A 其實是 Model B Raspberry Pi 的簡化版，沒有乙太網路、只有一個 USB 插口，以及 256MB 的記憶體，但與 Model B 相較，僅需 1/3 的電力就可順暢運作，相當適合於只用一顆電池或透過太陽能供電的各式裝置，例如微型機器人、遠端感應裝置，或是一般建置於公車站牌的 Wi-Fi repeaters 等電子產品。Raspberry Pi 發言人 Liz Upton 表示：希望在不久的未來，全世界的使用者都可以在其國家購買到 Raspberry Pi，目前也正規劃朝這個方向努力，因為透過開放式的軟硬體架構，使用者將可以善用裝置原始設計者嘔心瀝血的成果，發揮其個別的創意來創造更好的作品！


相關網址：

1、Raspberry Pi Model A 在歐洲開賣 
http://www.h-online.com/open/news/item/Raspberry-Pi-Model-A-now-on-sale-in-Europe-1797183.html

2、25美金的 Raspberry Pi 終於上市
http://arstechnica.com/information-technology/2013/02/long-promised-25-raspberry-pi-finally-goes-on-sale/
_______________________________________________________________

■ [源碼新聞] Valve 釋出 Steam for Linux

黃郁文／編譯

還在懷疑 Linux 平台上沒有遊戲市場嗎？ Steam for Linux 終於正式上線提供服務了。Steam for Linux 官方版本是為 Ubuntu Linux 所設計，使用者可於 Ubuntu 作業系統的線上軟體中心下載到這些遊戲，至於 Fedora Linux 的使用者，亦可透過 Tom Callaway 所開發與維護的 Steam yum repo，來進行體驗。

雖然在自由開源的作業系統上進行封閉源碼遊戲的操作，觸碰到一些開源理念的衝擊與爭議，對於某些開源理念的堅守者並不是能夠全部接受，不過這種應用方式目前看來似乎已經是大勢所趨，並被逐步實現了。也為了慶祝 Steam 線上平台新添 Linux 運作遊戲，目前該平台上約有 60 款能適用於 Linux 下的遊戲，包括 Half-Life、Counter-Strike、Space Pirates And Zombies 這幾款熱賣產品。對於這些遊戲有興趣的 Linux 使用者，可以進一步在 Linux Steam Game Hub 這個網站上，找到 Valve 相關的各類新聞！


相關網址：

1、Linux 使用者終於可以透過 Steam 平台執行熱門遊戲了
http://opensource.com/life/13/2/steam-client-finally-available-all-linux-users-game-sale

2、GNU 創立者 Stallman 認為 Steam 線上平台將要散布 Linux 下執行的 DRM 遊戲是不盡然道德的
http://www.openfoundry.org/tw/foss-news/8767-gnu-stallman-steam-linux-drm-

3、Valve 證實將在 Ubuntu 上推出 Steam 客戶端及遊戲「惡靈勢力 2」
http://www.openfoundry.org/tw/foss-news/8759-valve-ubuntu-steam-2
_______________________________________________________________

■ [源碼新聞] Document Foundation 發表 LibreOffice 4.0

謝良奇／編譯 

Document Foundation (http://www.documentfoundation.org/) 日前發表了 LibreOffice 4.0，這是該社群自 2001 年以來所一直夢想的自由辦公室套件。LibreOffice 4.0 是第一個體現了該社群在發表之初所設定目標的釋出版本，這些目標包括更乾淨簡潔的程式碼、功能改進、更好的互通性，以及更為多元與包容的生態系統。

在不到 30 個月的時間裡，LibreOffice 大幅度成長為聚焦終端用戶桌面生產力的最大獨立自由軟體專案。Document Foundation 包容性的管理與公共版權 (copyleft) 授權都有助於吸引超過 500 位開發者，其中有四分之三是獨立志願者，貢獻出的程式提交 (commit) 超過 5 萬個。

這份程式碼基礎與原有程式大不相同，新增與刪除的部分有數百萬行程式碼，包括增加新功能、解決臭蟲、採納最先進的 C++ constructs、更換工具、揚棄過時方法與程式庫，以及將 25000 行德文註解翻譯為英文。這些工作使得程式碼更易於理解，且更有利於社群新成員的參與。

基金會董事會主席 Florian Effenberger 表示，LibreOffice 4.0 在互通性上是一個里程碑，也是他們持續改進使用者介面的絕佳基礎。他們的專案不僅有能力定期吸引新的開發者，更為基於強大自由軟體浪潮的合作，創造了透明的平台，在這裡企業提供贊助，志願者進行開發以實現同樣的目標。

LibreOffice 4.0 提供數量眾多的新功能，包括：

＊與若干內容和文件管理系統的整合，像是 Alfresco、IBM FileNet P8、Microsoft Sharepoint 2010、Nuxeo、OpenText、SAP NetWeaver Cloud Service 等。
＊由於若干新功能與改進，例如匯入 ink annotations 以及為文字範圍 (text ranges) 附加註解等，為 DOCX 與 RTF 文件提供了更好的互通性。
＊Microsoft Publisher 文件的匯入功能與 Visio 匯入過濾器的改進。
＊無需額外的頁面風格，即可在 Writer 文件首頁採用不同的頁首與頁尾。
＊額外的使用者介面改進，包括 Unity 整合、支援 Firefox Themes 提供 LibreOffice 個人化外觀。
＊Calc 的若干效能改進，還有新功能如匯出圖表為 JPG 與 PNG 圖片，以及像是定義於 ODF OpenFormula 中的新試算表函數。
＊首次釋出針對 Android 的 Impress 遠端控制應用程式，僅提供部分 Linux 散佈套件支援。然而不久後的第二次釋出，將支援所有平台，包括 Windows、MacOS X 與所有 Linux 散佈套件。
＊針對載入與儲存許多類型檔案，有顯著的效能提升，特別是大型 ODS 與 XLSX 試算表，以及 RTF 檔案。


相關網址：
1. Document Foundation 發表 LibreOffice 4.0
http://blog.documentfoundation.org/2013/02/07/the-document-foundation-announces-libreoffice-4-0/
_______________________________________________________________

■ [源碼新聞] Microsoft 發布德國慕尼黑市 Linux 轉換計畫調查報告與官方分析有明顯落差

黃郁文／編譯

Microsoft 在前陣子發布了一份，其委由 HP 製作有關德國慕尼黑市，將公用電腦系統由 Windows 轉換成 Linux 的統計報告。據德國 Focus Money Online 雜誌報導，Microsoft 此份報告顯示，慕尼黑市的轉換計畫將耗費超過 6 千萬歐元，遠遠超過當初政府部門本身所評估的預期經費。對此，Microsoft 德國子公司出面強調該份報告僅供公司內部市場分析使用，原不打算對外公開。但之後、眾多論者評議 Microsoft 引用無法驗證的非公開研究來抨擊市政，是不盡負責與具商業道德的行為，為了冷卻這樣的批評，Microsoft 進一步整理該份研究報告的相關數據，並輔以圖表來呈現其分析結果。

然而，這些追加呈現的分析資料，仍然在比對上存有許多主觀而無法被驗證分析的資訊，二個被批評家標示出疑點重重的要點包括：

＊避重就輕：Microsoft 發布的綜合報告指出，慕尼黑市將所有系統由舊版 Windows NT 4 及其 Office 轉換為 Linux 與 OpenOffice，整體成本需耗費 6 千萬歐元；而升級至 Windows XP 及其搭配之 Office 2003，僅需花費 1 千 7 百萬歐元，此一分析數據看似選用 Windows 作業系統可節省市政資訊系統支出達 4 千 3 百萬歐元之譜，然而，Microsoft 本身對於舊版 Windows XP 已階段性撤出商業支援的市場，若其是以當前主打之 Win7 與 Win8，及更新版本的 Office 系統來進行估算，則就 Windows 系統方面的升級成本，根本不可能低至此份報告書估算之數值，甚至可能還會高於 Linux 系統的轉換成本。

＊以少報多：Microsoft 報告書的計算基礎，是假設要將所有的私有軟體 (proprietary software)，皆轉換移植到 Linux 作業系統上，但實際上慕尼黑市的務實作法並不是循此種地毯式高耗成本的方案，LiMux Project 在進行轉換時，會指定部份的私有軟體與機器，繼續透過虛擬 Windows XP 作業系統的方式，來讓多數的 Linux 系統程式與其能夠進行檔案與格式的交換，如此一來、在一個 30 個行政處理人員的辦公室，僅需一至二台電腦仍運轉額外支付授權金取得的 Windows 作業系統，即可處理不同系統之間格式轉換的需求，更得以大為降低前述的轉換成本。故 LiMux Project 官方提出的分析資料指出，採用 Linux 與 OpenOffice 替換 Windows 與 Microsoft Office 反可節省近 1 千萬歐元的資訊系統維護成本。

截至目前為止，慕尼黑市官方尚未對微軟此份報告及其分析圖表的細節表示意見。在歐洲具有一定使用率的自由開源系統建置專案 LedgerSMB project 開發者 Chris Travers 則表示：他不質疑 Microsoft 此份報告「數據上」的正確性，但依他過往經驗，數據的解讀方式與方向，很容易發生人為的操縱與誤導。並且，Linux 轉換成本的高低與否，也並非據以評判此項施政的唯一數據，因為資訊系統的轉換，不應單單僅是著眼於成本簡省，而更應該從策略投資的角度，為市府持續性的資訊服務系統，規劃出合身剪裁的解決與優化方案，從這個角度來看，採納自由開源軟體進行系統轉換，絕對能帶來長遠性的利益。」


相關網址：

1、Microsoft 發布部分慕尼黑市 Linux 轉換計畫調查報告 
http://www.h-online.com/open/news/item/Microsoft-partly-releases-study-on-Munich-s-Linux-migration-1792733.html

2、Microsoft 決定不發布質疑慕尼黑市轉換專案成功性的相關資訊
http://www.itworld.com/open-source/337658/microsoft-wont-release-study-challenged-success-munichs-linux-migration

3、Microsoft 對於慕尼黑轉換計畫轉趨沉默
http://www.linuxinsider.com/story/77174.html
_______________________________________________________________

■ [源碼新聞] Drupal Taiwan 3 月的各地聚會資訊，歡迎踴躍參加！

OSSF 電子報團隊／整理 

Drupal Taiwan 最近在台北、嘉義、高雄分別舉辦了一連串的分享會／聚會，有興趣的朋友請快來看看，不要錯過囉！

Drupal 嘉義小聚 - 關於 PhoneGap 如何與 Drupal 這套 CMS 搭配合作（3/9）
地點：吳鳳科技大學資管系生有樓二樓 SB 209（嘉義縣民雄鄉建國路二段 117 號）
時間：14:00~16:00
活動資訊：http://drupaltaiwan.org/forum/20130115/6967

Drupal 台北 3 月分享會 - Drupal 7 商務網站與 PayPal 金流實作（3/16）
地點：GozCafe 果子咖啡（台北市松山區民生東路三段 140 巷 11 號）
時間：14:30~17:30
活動資訊：http://drupaltaiwan.org/forum/20130219/7069

Drupal 高雄小聚 （3/23）
地點：高雄市前鎮區復興四路 2 號 7 樓 708 室
時間：14:00~17:00
活動資訊：http://drupaltaiwan.org/forum/20130226/7092
_______________________________________________________________


□ 關於本報 □__________________________________________________

◎ 主編︰洪華超
◎ 法律專欄編輯︰葛冬梅
◎ 技術編輯︰曾義峰
◎ 執行編輯︰王怡凱、林誠夏、林珈宏、陳蕙蓁、彭冠雯
◎ 外稿編譯︰黃湘婷、黃郁文、蕭惟杰、謝良奇

本電子報自行採訪、報導、編譯、撰寫文章之智慧財產權屬於中央研究院，採用創用 CC「姓名標示－禁止改作－非商業性」授權條款臺灣 3.0 版授權散布，歡迎在不變更內容的前提下，以任何形式重製與散布本報，但必須遵守下列義務︰（1）不得為商業目的之利用；（2）必須標明本電子報智慧財產權屬於中央研究院；（3）完整引用本著作權說明。

若欲以創用 CC「姓名標示－禁止改作－非商業性」授權條款臺灣 3.0 版以外的方式利用上述文章，請與自由軟體鑄造場編輯群（ossfepaper at openfoundry.org）聯絡。

非自由軟體鑄造場自行撰寫的單篇文章，其智慧財產權利屬於原作者所有，其以非專屬的方式授權予自由軟體鑄造場運用，而與本電子報其他文章併以創用 CC「姓名標示－禁止改作－非商業性」授權條款臺灣 3.0 版的方式進行散布。

若欲以創用 CC「姓名標示－禁止改作－非商業性」授權條款臺灣 3.0 版以外的方式利用個別作者的文章，請自行與該作者聯繫，或透過自由軟體鑄造場編輯群（ossfepaper at openfoundry.org）來轉發聯絡訊息。

授權條款全文請見︰
http://creativecommons.org/licenses/by-sa/3.0/tw/legalcode
授權條款簡介請見︰
http://creativecommons.org/licenses/by-sa/3.0/tw/deed.zh_TW

若欲訂閱本電子報，請至以下網址︰
http://www.openfoundry.org/tw/news

如欲取消訂閱這份電子報，可透過自由軟體鑄造場新聞首頁左上方之自動退訂機制︰
http://www.openfoundry.org/tw/news

或寄發電子郵件至︰ossfepaper@openfoundry.org，以進行人工退訂。